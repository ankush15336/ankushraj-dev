<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DAA - Unit 1 | ankushraj.dev</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --primary: #3b82f6;
            --secondary: #8b5cf6;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --text: #333;
            --text-light: #6b7280;
            --bg: #f5f7fa;
            --card-bg: #ffffff;
            --border: #e5e7eb;
            --code-bg: #f3f4f6;
        }
        
        body.dark-mode {
            --text: #f0f0f0;
            --text-light: #9ca3af;
            --bg: #111827;
            --card-bg: #1f2937;
            --border: #374151;
            --code-bg: #374151;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
            transition: background 0.3s, color 0.3s;
        }
        
        /* Print Watermark */
        @media print {
            @page {
                margin: 15mm 10mm 12mm 10mm;
                size: A4;
            }
            
            body {
                position: relative;
                font-size: 13px;
                line-height: 1.45;
            }
            
            body::before {
                content: "ankushraj.dev";
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%) rotate(-45deg);
                font-size: 70px;
                font-weight: 200;
                color: rgba(0, 0, 0, 0.04);
                z-index: -1;
                pointer-events: none;
                letter-spacing: 6px;
                white-space: nowrap;
                width: 100%;
                text-align: center;
            }
            
            body.dark-mode::before {
                color: rgba(0, 0, 0, 0.04);
            }
            
            .header-controls,
            .tabs-container,
            .toc-panel,
            .overlay {
                display: none !important;
            }
            
            .header {
                position: relative;
                page-break-after: avoid;
                padding: 8px 0 !important;
                margin-bottom: 12px !important;
            }
            
            .header-title {
                text-align: center !important;
            }
            
            .header-title h1 {
                font-size: 22px !important;
                margin-bottom: 3px !important;
            }
            
            .header-title p {
                font-size: 13px !important;
            }
            
            .chapter-title {
                page-break-after: avoid;
                page-break-inside: avoid;
                margin-bottom: 12px !important;
                padding: 12px 14px !important;
                font-size: 17px !important;
            }
            
            .section {
                page-break-inside: avoid;
                margin-bottom: 14px !important;
            }
            
            .section-title {
                margin-bottom: 8px !important;
                padding-bottom: 5px !important;
                font-size: 15px !important;
            }
            
            .subsection-title {
                margin-top: 10px !important;
                margin-bottom: 5px !important;
                font-size: 13px !important;
            }
            
            .content p {
                margin-bottom: 7px !important;
                line-height: 1.5 !important;
            }
            
            .definition-box,
            .code-box,
            .advantage-box,
            .threat-box,
            .step-box,
            .example-box,
            .mindmap-box,
            .note-box,
            .formula-box {
                margin: 7px 0 !important;
                padding: 9px !important;
                page-break-inside: avoid;
                font-size: 12px !important;
                line-height: 1.5 !important;
            }
            
            .point {
                margin-bottom: 5px !important;
                font-size: 12px !important;
            }
            
            .divider {
                margin: 12px 0 !important;
                height: 1px !important;
            }
            
            .container {
                max-width: 100% !important;
                padding: 0 !important;
            }
            
            .footer {
                margin-top: 15px !important;
                padding: 10px 0 !important;
                page-break-inside: avoid;
            }
            
            .footer-credit {
                font-size: 13px !important;
            }
            
            .footer-note {
                font-size: 10px !important;
            }
        }
        
        /* Header */
        .header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
            padding: 12px 16px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .header-title {
            text-align: center;
        }
        
        .header-title h1 {
            font-size: 24px;
            font-weight: 800;
            margin-bottom: 4px;
        }
        
        .header-title p {
            font-size: 14px;
            opacity: 0.9;
        }
        
        .header-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 12px;
        }
        
        .btn {
            flex: 1;
            max-width: 150px;
            padding: 10px 16px;
            border: none;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.25);
            color: white;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            backdrop-filter: blur(10px);
        }
        
        .btn:hover {
            background: rgba(255, 255, 255, 0.35);
            transform: translateY(-2px);
        }
        
        .btn:active {
            transform: scale(0.95);
        }
        
        /* Tabs */
        .tabs-container {
            background: var(--card-bg);
            border-bottom: 2px solid var(--border);
            display: flex;
        }
        
        .tab {
            flex: 1;
            padding: 16px;
            text-align: center;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            color: var(--text-light);
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }
        
        .tab:active {
            transform: scale(0.98);
        }
        
        .tab.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
            background: rgba(59, 130, 246, 0.05);
        }
        
        /* TOC Panel */
        .toc-panel {
            display: none;
            position: fixed;
            left: 0;
            top: 0;
            width: 85%;
            max-width: 320px;
            height: 100vh;
            background: var(--card-bg);
            z-index: 1000;
            overflow-y: auto;
            box-shadow: 4px 0 12px rgba(0,0,0,0.2);
            transform: translateX(-100%);
            transition: transform 0.3s ease;
        }
        
        .toc-panel.active {
            display: block;
            transform: translateX(0);
        }
        
        .toc-header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
            padding: 16px;
            font-size: 16px;
            font-weight: 700;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .toc-close {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .toc-list {
            list-style: none;
            padding: 0;
        }
        
        .toc-list li {
            padding: 14px 16px;
            font-size: 13px;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .toc-list li:hover {
            background: var(--bg);
            color: var(--primary);
            padding-left: 24px;
        }
        
        .toc-list li:active {
            transform: scale(0.98);
        }
        
        /* Overlay */
        .overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 999;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .overlay.active {
            display: block;
            opacity: 1;
        }
        
        /* Content */
        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 12px;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
            animation: fadeIn 0.4s ease;
        }
        
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .section {
            margin-bottom: 24px;
        }
        
        .chapter-title {
            font-size: 18px;
            font-weight: 800;
            color: white;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            padding: 14px 16px;
            margin-bottom: 16px;
            margin-left: -12px;
            margin-right: -12px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .section-title {
            font-size: 16px;
            font-weight: 700;
            color: var(--primary);
            margin-bottom: 10px;
            padding-bottom: 6px;
            border-bottom: 2px solid var(--primary);
        }
        
        .subsection-title {
            font-size: 14px;
            font-weight: 700;
            color: var(--text);
            margin-top: 12px;
            margin-bottom: 6px;
        }
        
        .content p {
            margin-bottom: 10px;
            font-size: 14px;
            line-height: 1.65;
        }
        
        /* Content Boxes */
        .definition-box,
        .code-box,
        .advantage-box,
        .threat-box,
        .step-box,
        .example-box,
        .mindmap-box,
        .note-box,
        .formula-box {
            padding: 12px;
            border-radius: 8px;
            margin: 10px 0;
            font-size: 13px;
            line-height: 1.65;
        }
        
        .definition-box {
            background: rgba(59, 130, 246, 0.1);
            border-left: 4px solid var(--primary);
        }
        
        .code-box {
            background: var(--code-bg);
            border-left: 4px solid #6b7280;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
            white-space: pre-wrap;
        }
        
        .advantage-box {
            background: rgba(16, 185, 129, 0.1);
            border-left: 4px solid var(--success);
        }
        
        .threat-box {
            background: rgba(239, 68, 68, 0.1);
            border-left: 4px solid var(--danger);
        }
        
        .step-box {
            background: rgba(245, 158, 11, 0.1);
            border-left: 4px solid var(--warning);
        }
        
        .example-box {
            background: rgba(139, 92, 246, 0.1);
            border-left: 4px solid var(--secondary);
        }
        
        .mindmap-box {
            background: rgba(139, 92, 246, 0.05);
            border: 2px dashed var(--secondary);
            text-align: center;
            padding: 20px;
        }
        
        .note-box {
            background: rgba(245, 158, 11, 0.1);
            border-left: 4px solid var(--warning);
        }
        
        .formula-box {
            background: rgba(139, 92, 246, 0.1);
            border: 2px solid var(--secondary);
            text-align: center;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 15px;
            font-weight: 700;
        }
        
        .point {
            margin-left: 18px;
            margin-bottom: 6px;
            font-size: 13px;
            position: relative;
        }
        
        .point::before {
            content: "‚Ä¢";
            position: absolute;
            left: -14px;
            color: var(--primary);
            font-weight: 700;
        }
        
        .divider {
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--border), transparent);
            margin: 24px 0;
        }
        
        /* Footer */
        .footer {
            text-align: center;
            padding: 16px;
            background: var(--card-bg);
            border-top: 2px solid var(--border);
            margin-top: 32px;
        }
        
        .footer-credit {
            font-size: 14px;
            color: var(--text);
            font-weight: 600;
        }
        
        .footer-credit strong {
            color: var(--primary);
            font-weight: 700;
        }
        
        .footer-note {
            font-size: 11px;
            color: var(--text-light);
            margin-top: 4px;
        }
        
        /* Responsive */
        @media (min-width: 768px) {
            .container {
                padding: 16px;
            }
            
            .header {
                padding: 14px 20px;
            }
            
            .header-title h1 {
                font-size: 28px;
            }
            
            .header-title p {
                font-size: 15px;
            }
            
            .chapter-title {
                font-size: 20px;
                padding: 16px 20px;
                margin-left: -16px;
                margin-right: -16px;
            }
            
            .section-title {
                font-size: 18px;
            }
            
            .content p {
                font-size: 15px;
                line-height: 1.7;
            }
            
            .definition-box,
            .code-box,
            .advantage-box,
            .threat-box,
            .step-box,
            .example-box,
            .mindmap-box,
            .note-box,
            .formula-box {
                padding: 14px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <!-- TOC Panel -->
    <div class="toc-panel" id="tocPanel">
        <div class="toc-header">
            <span>üìö Chapters</span>
            <button class="toc-close" onclick="closeTOC()">√ó</button>
        </div>
        <ul class="toc-list" id="tocList">
            <!-- Dynamically generated -->
        </ul>
    </div>
    
    <!-- Overlay -->
    <div class="overlay" id="overlay" onclick="closeTOC()"></div>
    
    <!-- Header -->
    <div class="header">
        <div class="header-title">
            <h1>Design & Analysis of Algorithms</h1>
            <p>Unit 1 - Understanding Fundamentals</p>
        </div>
        
        <div class="header-controls">
            <button class="btn" onclick="openTOC()">
                <span>üìë</span>
                <span>Chapters</span>
            </button>
            <button class="btn" id="darkModeBtn" onclick="toggleDarkMode()">
                <span>üåô</span>
                <span>Dark</span>
            </button>
            <button class="btn" onclick="window.print()">
                <span>üì•</span>
                <span>PDF</span>
            </button>
        </div>
    </div>
    
    <!-- Tabs -->
    <div class="tabs-container">
        <div class="tab active" onclick="switchTab('full')">
            üìñ Full Notes
        </div>
        <div class="tab" onclick="switchTab('lastmin')">
            ‚ö° Last Min Notes
        </div>
    </div>
    
    <!-- Content Container -->
    <div class="container">
        <!-- FULL NOTES TAB -->
        <div class="tab-content active" id="fullNotesTab">
            
            <!-- CHAPTER: ALGORITHM AND PROGRAM PERFORMANCE -->
            <div class="chapter-title" id="ch1">
                <span>üéØ</span>
                <span>Chapter 1 ‚Äî Algorithm and Program Performance</span>
            </div>
            
            <!-- Mind Map -->
            <div class="section">
                <div class="mindmap-box">
                    <strong style="color: var(--secondary); font-size: 16px;">üìä ALGORITHM PERFORMANCE - MIND MAP</strong>
                    <div style="margin-top: 15px; text-align: left; max-width: 700px; margin-left: auto; margin-right: auto;">
                        <div class="point">Algorithm ‚Üí Step-by-step procedure to solve a problem</div>
                        <div class="point">Time Complexity ‚Üí How running time grows with input size</div>
                        <div class="point">Space Complexity ‚Üí How memory usage grows with input size</div>
                        <div class="point">Analysis Types ‚Üí Best Case, Average Case, Worst Case</div>
                        <div class="point">Asymptotic Notations ‚Üí Big O, Omega, Theta (growth comparison)</div>
                        <div class="point">Recurrence ‚Üí Substitution, Recursion Tree, Master Method</div>
                    </div>
                </div>
            </div>
            
            <!-- Section 1: What is an Algorithm -->
            <div class="section">
                <div class="section-title">1. What is an Algorithm?</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>Definition:</strong><br>
                        An algorithm is a step-by-step procedure or set of rules designed to solve a specific problem or perform a specific task. Think of it as a recipe for solving a problem.
                    </div>
                    
                    <div class="example-box">
                        <strong>Real-life Example - Making Tea:</strong><br>
                        Step 1: Boil water<br>
                        Step 2: Add tea leaves<br>
                        Step 3: Add sugar<br>
                        Step 4: Add milk<br>
                        Step 5: Strain and serve<br><br>
                        This is an algorithm for making tea! Similarly, algorithms in programming solve computational problems.
                    </div>
                    
                    <div class="subsection-title">Characteristics of a Good Algorithm:</div>
                    <div class="step-box">
                        <strong>1. Input:</strong> Algorithm should have zero or more inputs (data we provide)<br>
                        <strong>2. Output:</strong> Must produce at least one output (result)<br>
                        <strong>3. Definiteness:</strong> Each step must be clear and unambiguous (no confusion)<br>
                        <strong>4. Finiteness:</strong> Must terminate after finite number of steps (should not run forever)<br>
                        <strong>5. Effectiveness:</strong> Each step must be simple enough to be executed<br>
                        <strong>6. Correctness:</strong> Should produce correct output for all valid inputs
                    </div>
                    
                    <div class="code-box"><strong>Example Algorithm - Find Maximum of Two Numbers:</strong>

Algorithm: FindMaximum
Input: Two numbers a and b
Output: Maximum number

Step 1: Start
Step 2: Read values of a and b
Step 3: If a > b then
           max = a
        Else
           max = b
Step 4: Print max
Step 5: Stop</div>
                    
                    <div class="note-box">
                        <strong>Algorithm vs Program:</strong><br>
                        ‚Ä¢ <strong>Algorithm:</strong> Language-independent solution (written in plain English or pseudocode)<br>
                        ‚Ä¢ <strong>Program:</strong> Implementation of algorithm in a specific programming language (Java, C++, Python)
                    </div>
                </div>
            </div>
            
            <!-- Section 2: Why Study Algorithms -->
            <div class="section">
                <div class="section-title">2. Why Study Algorithms?</div>
                <div class="content">
                    <div class="advantage-box">
                        <strong>‚úì Efficiency:</strong> Helps write faster programs (less time)<br>
                        <strong>‚úì Optimization:</strong> Reduces memory usage (less space)<br>
                        <strong>‚úì Problem Solving:</strong> Improves logical thinking and coding skills<br>
                        <strong>‚úì Scalability:</strong> Ensures program works well with large data<br>
                        <strong>‚úì Career:</strong> Important for interviews and competitive programming
                    </div>
                    
                    <div class="example-box">
                        <strong>Real-life Impact:</strong><br>
                        ‚Ä¢ Google Search uses algorithms to find results in milliseconds from billions of web pages<br>
                        ‚Ä¢ GPS uses algorithms to find shortest route<br>
                        ‚Ä¢ Netflix uses algorithms to recommend shows<br>
                        ‚Ä¢ Banks use algorithms for fraud detection
                    </div>
                </div>
            </div>
            
            <!-- Section 3: Time Complexity -->
            <div class="section">
                <div class="section-title">3. Time Complexity</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>What is Time Complexity?</strong><br>
                        Time complexity is a measure of the amount of time an algorithm takes to run as a function of the input size. It tells us how the running time grows when the input size increases.
                    </div>
                    
                    <p><strong>Important:</strong> We don't measure actual time in seconds (that depends on computer speed). Instead, we count the number of operations performed.</p>
                    
                    <div class="example-box">
                        <strong>Simple Example - Printing Numbers:</strong><br><br>
                        <strong>Algorithm 1:</strong> Print numbers 1 to n<br>
                        for (i = 1 to n)<br>
                        &nbsp;&nbsp;print i<br><br>
                        Operations: n times (one print for each number)<br>
                        Time Complexity: O(n) - grows linearly with input<br><br>
                        
                        <strong>Algorithm 2:</strong> Print all pairs<br>
                        for (i = 1 to n)<br>
                        &nbsp;&nbsp;for (j = 1 to n)<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;print (i, j)<br><br>
                        Operations: n √ó n = n¬≤ times<br>
                        Time Complexity: O(n¬≤) - grows quadratically
                    </div>
                    
                    <div class="subsection-title">Common Time Complexities (from fastest to slowest):</div>
                    <div class="code-box"><strong>Time Complexity Hierarchy:</strong>

O(1)       ‚Üí Constant       ‚Üí Same time for any input
O(log n)   ‚Üí Logarithmic    ‚Üí Binary search
O(n)       ‚Üí Linear         ‚Üí Single loop
O(n log n) ‚Üí Linearithmic   ‚Üí Merge sort, Quick sort
O(n¬≤)      ‚Üí Quadratic      ‚Üí Nested loops
O(n¬≥)      ‚Üí Cubic          ‚Üí Triple nested loops
O(2‚Åø)      ‚Üí Exponential    ‚Üí Fibonacci (naive)
O(n!)      ‚Üí Factorial      ‚Üí Permutations

<strong>Best to Worst:</strong> O(1) < O(log n) < O(n) < O(n log n) < O(n¬≤) < O(2‚Åø) < O(n!)</div>
                    
                    <div class="note-box">
                        <strong>Remember:</strong><br>
                        ‚Ä¢ Lower time complexity = Faster algorithm<br>
                        ‚Ä¢ We always analyze for large input sizes (as n ‚Üí ‚àû)<br>
                        ‚Ä¢ We ignore constants (2n and 5n both are O(n))
                    </div>
                </div>
            </div>
            
            <!-- Section 4: Space Complexity -->
            <div class="section">
                <div class="section-title">4. Space Complexity</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>What is Space Complexity?</strong><br>
                        Space complexity is the amount of memory space required by an algorithm to run as a function of the input size. It includes both auxiliary space and space used by input.
                    </div>
                    
                    <div class="formula-box">
                        Space Complexity = Auxiliary Space + Input Space
                    </div>
                    
                    <div class="example-box">
                        <strong>Example 1 - Sum of Array Elements:</strong><br>
                        <code>
                        int sum = 0;<br>
                        for (i = 0 to n-1)<br>
                        &nbsp;&nbsp;sum = sum + arr[i]<br>
                        </code><br><br>
                        Variables used: sum, i (only 2 variables)<br>
                        Space Complexity: O(1) - constant space<br>
                        (Space doesn't grow with input size)
                    </div>
                    
                    <div class="example-box">
                        <strong>Example 2 - Copy Array:</strong><br>
                        <code>
                        Create new array temp[n]<br>
                        for (i = 0 to n-1)<br>
                        &nbsp;&nbsp;temp[i] = arr[i]<br>
                        </code><br><br>
                        Extra array of size n created<br>
                        Space Complexity: O(n) - linear space<br>
                        (Space grows with input size)
                    </div>
                    
                    <div class="note-box">
                        <strong>Time vs Space Trade-off:</strong><br>
                        Sometimes we can make algorithm faster by using more memory, or save memory by taking more time. This is called time-space trade-off.
                    </div>
                </div>
            </div>
            
            <div class="divider"></div>
            <!-- Section 5: Case Analysis -->
            <div class="section">
                <div class="section-title">5. Average and Worst Case Analysis</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>What is Case Analysis?</strong><br>
                        Case analysis means analyzing an algorithm's performance under different scenarios. We typically analyze three cases: Best Case, Average Case, and Worst Case.
                    </div>
                    
                    <div class="subsection-title">1. Best Case Analysis</div>
                    <div class="definition-box">
                        <strong>Best Case:</strong> The scenario where the algorithm performs the minimum number of operations. This is the most optimistic situation.
                    </div>
                    
                    <div class="example-box">
                        <strong>Example - Linear Search:</strong><br>
                        Task: Find element 'x' in array [10, 20, 30, 40, 50]<br>
                        If x = 10 (first element), we find it in just 1 comparison.<br>
                        <strong>Best Case Time:</strong> O(1) - constant time
                    </div>
                    
                    <div class="subsection-title">2. Average Case Analysis</div>
                    <div class="definition-box">
                        <strong>Average Case:</strong> The expected performance when considering all possible inputs. We calculate the average number of operations across all scenarios.
                    </div>
                    
                    <div class="example-box">
                        <strong>Example - Linear Search:</strong><br>
                        Array: [10, 20, 30, 40, 50]<br>
                        Element could be at any position (or not present)<br>
                        Average comparisons = (1 + 2 + 3 + 4 + 5) / 5 = 3<br>
                        <strong>Average Case Time:</strong> O(n) - linear time
                    </div>
                    
                    <div class="subsection-title">3. Worst Case Analysis</div>
                    <div class="definition-box">
                        <strong>Worst Case:</strong> The scenario where the algorithm performs the maximum number of operations. This is the most pessimistic situation and most commonly used for analysis.
                    </div>
                    
                    <div class="example-box">
                        <strong>Example - Linear Search:</strong><br>
                        Array: [10, 20, 30, 40, 50]<br>
                        If x = 50 (last element) or x is not present, we check all n elements.<br>
                        <strong>Worst Case Time:</strong> O(n) - linear time
                    </div>
                    
                    <div class="code-box"><strong>Case Analysis Summary for Common Algorithms:</strong>

Algorithm         | Best Case  | Average Case | Worst Case
----------------- | ---------- | ------------ | ----------
Linear Search     | O(1)       | O(n)         | O(n)
Binary Search     | O(1)       | O(log n)     | O(log n)
Bubble Sort       | O(n)       | O(n¬≤)        | O(n¬≤)
Quick Sort        | O(n log n) | O(n log n)   | O(n¬≤)
Merge Sort        | O(n log n) | O(n log n)   | O(n log n)</div>
                    
                    <div class="note-box">
                        <strong>Why Worst Case is Important:</strong><br>
                        ‚Ä¢ Guarantees algorithm won't perform worse than this<br>
                        ‚Ä¢ Useful for critical systems (medical, aviation, banking)<br>
                        ‚Ä¢ Provides upper bound on running time<br>
                        ‚Ä¢ Most commonly used in analysis
                    </div>
                    
                    <div class="example-box">
                        <strong>Detailed Example - Insertion Sort:</strong><br><br>
                        <strong>Best Case:</strong> Array is already sorted [1, 2, 3, 4, 5]<br>
                        ‚Üí Only n-1 comparisons needed ‚Üí O(n)<br><br>
                        
                        <strong>Average Case:</strong> Array is randomly ordered<br>
                        ‚Üí Average of n¬≤/4 comparisons ‚Üí O(n¬≤)<br><br>
                        
                        <strong>Worst Case:</strong> Array is reverse sorted [5, 4, 3, 2, 1]<br>
                        ‚Üí Maximum comparisons: 1+2+3+...+(n-1) = n(n-1)/2 ‚Üí O(n¬≤)
                    </div>
                </div>
            </div>
            
            <!-- Section 6: Asymptotic Notations -->
            <div class="section">
                <div class="section-title">6. Asymptotic Notations</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>What are Asymptotic Notations?</strong><br>
                        Asymptotic notations are mathematical tools used to describe the running time of an algorithm when the input size approaches infinity. They help us compare algorithms by ignoring constant factors and focusing on growth rate.
                    </div>
                    
                    <p><strong>Why "Asymptotic"?</strong> We analyze how the algorithm behaves as input size (n) becomes very large (tends to infinity).</p>
                    
                    <div class="subsection-title">Three Main Asymptotic Notations:</div>
                    <div class="step-box">
                        <strong>1. Big O (O)</strong> - Upper Bound (Worst Case)<br>
                        <strong>2. Big Omega (Œ©)</strong> - Lower Bound (Best Case)<br>
                        <strong>3. Big Theta (Œò)</strong> - Tight Bound (Average Case)
                    </div>
                </div>
            </div>
            
            <!-- Section 7: Big O Notation -->
            <div class="section">
                <div class="section-title">7. Big O Notation (Upper Bound)</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>Big O Notation:</strong><br>
                        Big O describes the upper bound of an algorithm's running time. It gives the worst-case scenario - the maximum time an algorithm could take.<br><br>
                        <strong>Think of it as:</strong> "The algorithm will take AT MOST this much time"
                    </div>
                    
                    <div class="formula-box">
                        f(n) = O(g(n))
                        
                        If there exist positive constants c and n‚ÇÄ such that:
                        f(n) ‚â§ c √ó g(n) for all n ‚â• n‚ÇÄ
                    </div>
                    
                    <div class="example-box">
                        <strong>Simple Explanation:</strong><br>
                        If an algorithm takes 3n¬≤ + 5n + 2 operations:<br>
                        ‚Ä¢ For large n, n¬≤ term dominates<br>
                        ‚Ä¢ We ignore constants (3, 5, 2)<br>
                        ‚Ä¢ We ignore lower order terms (5n, 2)<br>
                        ‚Ä¢ Big O = O(n¬≤)<br><br>
                        This means the algorithm won't take more than n¬≤ time (ignoring constants).
                    </div>
                    
                    <div class="code-box"><strong>Examples of Big O:</strong>

Function          | Big O        | Name
----------------- | ------------ | ------------
5                 | O(1)         | Constant
3n + 2            | O(n)         | Linear
2n¬≤ + 5n + 1      | O(n¬≤)        | Quadratic
n¬≥ + 2n¬≤ + n      | O(n¬≥)        | Cubic
2‚Åø + n¬≤           | O(2‚Åø)        | Exponential
log(n) + 5        | O(log n)     | Logarithmic
n log(n) + n      | O(n log n)   | Linearithmic

<strong>Rule:</strong> Keep only the fastest growing term, drop constants</div>
                    
                    <div class="example-box">
                        <strong>Real Code Example:</strong><br>
                        <code>
                        for (i = 0; i < n; i++) {<br>
                        &nbsp;&nbsp;for (j = 0; j < n; j++) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;print(i, j);<br>
                        &nbsp;&nbsp;}<br>
                        }<br>
                        </code><br><br>
                        Outer loop: n times<br>
                        Inner loop: n times for each outer iteration<br>
                        Total operations: n √ó n = n¬≤<br>
                        <strong>Big O = O(n¬≤)</strong>
                    </div>
                    
                    <div class="note-box">
                        <strong>Important Properties:</strong><br>
                        ‚Ä¢ O(n) + O(n) = O(n) - we keep the higher order<br>
                        ‚Ä¢ O(n) √ó O(n) = O(n¬≤) - we multiply<br>
                        ‚Ä¢ O(2n) = O(n) - constants are dropped<br>
                        ‚Ä¢ O(n¬≤ + n) = O(n¬≤) - lower order terms dropped
                    </div>
                </div>
            </div>
            
            <!-- Section 8: Big Omega Notation -->
            <div class="section">
                <div class="section-title">8. Big Omega Notation (Œ©) - Lower Bound</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>Big Omega Notation:</strong><br>
                        Big Omega describes the lower bound of an algorithm's running time. It gives the best-case scenario - the minimum time an algorithm could take.<br><br>
                        <strong>Think of it as:</strong> "The algorithm will take AT LEAST this much time"
                    </div>
                    
                    <div class="formula-box">
                        f(n) = Œ©(g(n))
                        
                        If there exist positive constants c and n‚ÇÄ such that:
                        f(n) ‚â• c √ó g(n) for all n ‚â• n‚ÇÄ
                    </div>
                    
                    <div class="example-box">
                        <strong>Example - Linear Search:</strong><br>
                        Best case: Element found at first position<br>
                        Time taken: 1 comparison (constant)<br>
                        <strong>Œ©(1)</strong> - Will take at least constant time<br><br>
                        
                        Even in the best case, we must do at least 1 comparison, so Œ©(1).
                    </div>
                    
                    <div class="example-box">
                        <strong>Example - Merge Sort:</strong><br>
                        Even in the best case (already sorted array), merge sort has to:<br>
                        ‚Ä¢ Divide the array: log n levels<br>
                        ‚Ä¢ Merge at each level: n operations<br>
                        Total: n log n operations<br>
                        <strong>Œ©(n log n)</strong> - Will take at least n log n time
                    </div>
                    
                    <div class="note-box">
                        <strong>Remember:</strong><br>
                        ‚Ä¢ Big O = Upper bound (worst case - maximum time)<br>
                        ‚Ä¢ Big Omega = Lower bound (best case - minimum time)<br>
                        ‚Ä¢ Big O is more commonly used in practice
                    </div>
                </div>
            </div>
            
            <!-- Section 9: Big Theta Notation -->
            <div class="section">
                <div class="section-title">9. Big Theta Notation (Œò) - Tight Bound</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>Big Theta Notation:</strong><br>
                        Big Theta describes the tight bound of an algorithm's running time. It means the algorithm's running time is bounded both from above and below by the same function.<br><br>
                        <strong>Think of it as:</strong> "The algorithm will take EXACTLY this much time (within constant factors)"
                    </div>
                    
                    <div class="formula-box">
                        f(n) = Œò(g(n))
                        
                        If f(n) = O(g(n)) AND f(n) = Œ©(g(n))
                        Then f(n) = Œò(g(n))
                    </div>
                    
                    <div class="example-box">
                        <strong>Simple Explanation:</strong><br>
                        If an algorithm has:<br>
                        ‚Ä¢ Best case = O(n¬≤)<br>
                        ‚Ä¢ Worst case = O(n¬≤)<br>
                        Then we can say it's <strong>Œò(n¬≤)</strong> (tight bound)<br><br>
                        
                        This means the algorithm always takes around n¬≤ time, regardless of input.
                    </div>
                    
                    <div class="example-box">
                        <strong>Example - Merge Sort:</strong><br>
                        Best case: Œ©(n log n)<br>
                        Worst case: O(n log n)<br>
                        Since both are same: <strong>Œò(n log n)</strong><br><br>
                        
                        Merge sort always takes n log n time, whether array is sorted, reverse sorted, or random.
                    </div>
                    
                    <div class="example-box">
                        <strong>Example - Simple Loop:</strong><br>
                        <code>
                        for (i = 0; i < n; i++) {<br>
                        &nbsp;&nbsp;print(i);<br>
                        }<br>
                        </code><br><br>
                        This loop ALWAYS runs exactly n times.<br>
                        Best case = n, Worst case = n<br>
                        <strong>Œò(n)</strong> - tight bound
                    </div>
                    
                    <div class="code-box"><strong>Comparison Table:</strong>

Notation | Meaning        | Example
-------- | -------------- | -------
O        | At most        | Algorithm takes at most n¬≤ time
Œ©        | At least       | Algorithm takes at least n time
Œò        | Exactly        | Algorithm takes exactly n log n time

<strong>Relationship:</strong>
If Œò(f(n)) exists, then O(f(n)) and Œ©(f(n)) both exist
But if O(f(n)) exists, Œò(f(n)) may not exist</div>
                </div>
            </section>
            
            <!-- Section 10: Comparing Notations -->
            <div class="section">
                <div class="section-title">10. Asymptotic Notations - Detailed Comparison</div>
                <div class="content">
                    <div class="code-box"><strong>Complete Comparison:</strong>

Aspect          | Big O (O)      | Big Omega (Œ©)  | Big Theta (Œò)
--------------- | -------------- | -------------- | --------------
Bound Type      | Upper bound    | Lower bound    | Tight bound
Represents      | Worst case     | Best case      | Average case
Meaning         | At most        | At least       | Exactly
Symbol          | ‚â§              | ‚â•              | =
Usage           | Most common    | Less common    | When both match

<strong>Mathematical Relation:</strong>
Œò(n) ‚äÜ O(n)  (Theta is subset of Big O)
Œò(n) ‚äÜ Œ©(n)  (Theta is subset of Omega)
If f(n) = Œò(g(n)), then f(n) = O(g(n)) AND f(n) = Œ©(g(n))</code></div>
                    
                    <div class="example-box">
                        <strong>Practical Example - Binary Search:</strong><br><br>
                        
                        <strong>Best Case (Œ©):</strong><br>
                        Element found in middle on first try<br>
                        Œ©(1) - at least constant time<br><br>
                        
                        <strong>Worst Case (O):</strong><br>
                        Element at end or not present<br>
                        Need to divide array log n times<br>
                        O(log n) - at most logarithmic time<br><br>
                        
                        <strong>Average Case (Œò):</strong><br>
                        On average, takes log n comparisons<br>
                        Œò(log n) - exactly logarithmic time
                    </div>
                    
                    <div class="note-box">
                        <strong>When to Use Which:</strong><br>
                        ‚Ä¢ Use <strong>Big O</strong> when analyzing worst-case (most common)<br>
                        ‚Ä¢ Use <strong>Big Omega</strong> when proving lower bounds<br>
                        ‚Ä¢ Use <strong>Big Theta</strong> when best and worst cases are same<br>
                        ‚Ä¢ In practice, "Big O" is used most frequently
                    </div>
                </div>
            </div>
            
            <!-- Section 11: Common Mistakes -->
            <div class="section">
                <div class="section-title">11. Common Mistakes in Complexity Analysis</div>
                <div class="content">
                    <div class="threat-box">
                        <strong>‚ö†Ô∏è Mistake 1: Not Dropping Constants</strong><br>
                        ‚ùå Wrong: O(2n) or O(5n¬≤)<br>
                        ‚úì Correct: O(n) and O(n¬≤)<br>
                        Constants are always dropped!<br><br>
                        
                        <strong>‚ö†Ô∏è Mistake 2: Not Dropping Lower Order Terms</strong><br>
                        ‚ùå Wrong: O(n¬≤ + n)<br>
                        ‚úì Correct: O(n¬≤)<br>
                        Keep only the highest order term!<br><br>
                        
                        <strong>‚ö†Ô∏è Mistake 3: Confusing Best/Worst Case with Big O/Omega</strong><br>
                        ‚Ä¢ Best case can still have Big O notation<br>
                        ‚Ä¢ Worst case can still have Big Omega notation<br>
                        ‚Ä¢ They are different concepts!<br><br>
                        
                        <strong>‚ö†Ô∏è Mistake 4: Thinking O(n) is Always Better than O(n¬≤)</strong><br>
                        For small n, O(n¬≤) with small constant might be faster<br>
                        Example: O(n¬≤) algorithm with 2n¬≤ operations vs O(n) with 1000n operations<br>
                        For n < 500, the O(n¬≤) is actually faster!
                    </div>
                </div>
            </div>
            
            <!-- Section 12: Practice Examples -->
            <div class="section">
                <div class="section-title">12. Practice: Finding Time Complexity</div>
                <div class="content">
                    <div class="example-box">
                        <strong>Example 1: Simple Loop</strong><br>
                        <code>
                        for (i = 0; i < n; i++) {<br>
                        &nbsp;&nbsp;print(i);<br>
                        }<br>
                        </code><br>
                        Loop runs n times ‚Üí <strong>O(n)</strong>
                    </div>
                    
                    <div class="example-box">
                        <strong>Example 2: Nested Loops (Same Limit)</strong><br>
                        <code>
                        for (i = 0; i < n; i++) {<br>
                        &nbsp;&nbsp;for (j = 0; j < n; j++) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;print(i, j);<br>
                        &nbsp;&nbsp;}<br>
                        }<br>
                        </code><br>
                        Outer: n times, Inner: n times ‚Üí n √ó n ‚Üí <strong>O(n¬≤)</strong>
                    </div>
                    
                    <div class="example-box">
                        <strong>Example 3: Nested Loops (Different Limits)</strong><br>
                        <code>
                        for (i = 0; i < n; i++) {<br>
                        &nbsp;&nbsp;for (j = 0; j < m; j++) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;print(i, j);<br>
                        &nbsp;&nbsp;}<br>
                        }<br>
                        </code><br>
                        Outer: n times, Inner: m times ‚Üí n √ó m ‚Üí <strong>O(n√óm)</strong>
                    </div>
                    
                    <div class="example-box">
                        <strong>Example 4: Loop with Division</strong><br>
                        <code>
                        for (i = n; i > 0; i = i/2) {<br>
                        &nbsp;&nbsp;print(i);<br>
                        }<br>
                        </code><br>
                        Each iteration divides by 2<br>
                        n ‚Üí n/2 ‚Üí n/4 ‚Üí ... ‚Üí 1<br>
                        Takes log‚ÇÇ(n) iterations ‚Üí <strong>O(log n)</strong>
                    </div>
                    
                    <div class="example-box">
                        <strong>Example 5: Sequential Code</strong><br>
                        <code>
                        for (i = 0; i < n; i++) {<br>
                        &nbsp;&nbsp;print(i);<br>
                        }<br>
                        for (j = 0; j < n; j++) {<br>
                        &nbsp;&nbsp;print(j);<br>
                        }<br>
                        </code><br>
                        First loop: O(n), Second loop: O(n)<br>
                        Total: O(n) + O(n) = O(2n) = <strong>O(n)</strong>
                    </div>
                    
                    <div class="example-box">
                        <strong>Example 6: Dependent Nested Loop</strong><br>
                        <code>
                        for (i = 0; i < n; i++) {<br>
                        &nbsp;&nbsp;for (j = 0; j < i; j++) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;print(i, j);<br>
                        &nbsp;&nbsp;}<br>
                        }<br>
                        </code><br>
                        When i=0: 0 times, i=1: 1 time, i=2: 2 times, ..., i=n-1: n-1 times<br>
                        Total: 0+1+2+...+(n-1) = n(n-1)/2 ‚Üí <strong>O(n¬≤)</strong>
                    </div>
                </div>
            </div>
            
            <div class="divider"></div>
            <!-- CHAPTER 2: RECURRENCE RELATIONS -->
            <div class="chapter-title" id="ch2">
                <span>üîÅ</span>
                <span>Chapter 2 ‚Äî Recurrence Equations & Solutions</span>
            </div>
            
            <!-- Mind Map -->
            <div class="section">
                <div class="mindmap-box">
                    <strong style="color: var(--secondary); font-size: 16px;">üìä RECURRENCE - MIND MAP</strong>
                    <div style="margin-top: 15px; text-align: left; max-width: 700px; margin-left: auto; margin-right: auto;">
                        <div class="point">Recurrence ‚Üí Function defined using smaller inputs</div>
                        <div class="point">Substitution ‚Üí Guess + Prove by induction</div>
                        <div class="point">Recursion Tree ‚Üí Draw tree, sum level costs</div>
                        <div class="point">Master Method ‚Üí T(n)=aT(n/b)+f(n) ‚Üí 3 cases</div>
                    </div>
                </div>
            </div>
            
            <!-- Section 1: Intro -->
            <div class="section">
                <div class="section-title">1. Recurrence Relations</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>Definition:</strong> An equation that defines a function in terms of itself with smaller inputs.
                    </div>
                    
                    <div class="code-box">Common Examples:
Binary Search: T(n) = T(n/2) + c
Merge Sort: T(n) = 2T(n/2) + cn
Factorial: T(n) = T(n-1) + c</div>
                </div>
            </div>
            
            <!-- Section 2: Substitution -->
            <div class="section">
                <div class="section-title">2. Substitution Method</div>
                <div class="content">
                    <div class="step-box">
                        Step 1: Guess solution<br>
                        Step 2: Prove by induction
                    </div>
                    
                    <div class="example-box">
                        <strong>Example: T(n) = 2T(n/2) + n</strong><br>
                        Guess: T(n) = cn log n<br>
                        Proof: T(n) = 2[c(n/2)log(n/2)] + n = cn log n ‚úì<br>
                        <strong>Result: Œò(n log n)</strong>
                    </div>
                </div>
            </div>
            
            <!-- Section 3: Tree -->
            <div class="section">
                <div class="section-title">3. Recursion Tree Method</div>
                <div class="content">
                    <div class="example-box">
                        <strong>T(n) = 2T(n/2) + n</strong><br>
                        Level 0: n ‚Üí n<br>
                        Level 1: n/2, n/2 ‚Üí n<br>
                        Level 2: 4√ó(n/4) ‚Üí n<br>
                        Height: log n<br>
                        Total: n √ó log n<br>
                        <strong>Result: Œò(n log n)</strong>
                    </div>
                </div>
            </div>
            
            <!-- Section 4: Master -->
            <div class="section">
                <div class="section-title">4. Master Method</div>
                <div class="content">
                    <div class="formula-box">
                        T(n) = aT(n/b) + f(n)
                        Compare f(n) with n^(log_b a)
                    </div>
                    
                    <div class="step-box">
                        <strong>Case 1:</strong> f(n) < n^(log a) ‚Üí T(n)=Œò(n^log a)<br>
                        <strong>Case 2:</strong> f(n) = n^(log a) ‚Üí T(n)=Œò(n^log a √ó log n)<br>
                        <strong>Case 3:</strong> f(n) > n^(log a) ‚Üí T(n)=Œò(f(n))
                    </div>
                    
                    <div class="code-box">Examples:
T(n)=2T(n/2)+n ‚Üí Case 2 ‚Üí Œò(n log n)
T(n)=T(n/2)+1 ‚Üí Case 2 ‚Üí Œò(log n)
T(n)=2T(n/2)+n¬≤ ‚Üí Case 3 ‚Üí Œò(n¬≤)</div>
                </div>
            </div>
            
            <div class="divider"></div>
            <!-- CHAPTER 3: DATA STRUCTURES REVIEW -->
            <div class="chapter-title" id="ch3">
                <span>üì¶</span>
                <span>Chapter 3 ‚Äî Review of Data Structures</span>
            </div>
            
            <!-- Mind Map -->
            <div class="section">
                <div class="mindmap-box">
                    <strong style="color: var(--secondary); font-size: 16px;">üìä DATA STRUCTURES - MIND MAP</strong>
                    <div style="margin-top: 15px; text-align: left; max-width: 700px; margin-left: auto; margin-right: auto;">
                        <div class="point">Linear ‚Üí Arrays, Stacks, Queues, Linked Lists</div>
                        <div class="point">Arrays ‚Üí Fixed size, contiguous memory, O(1) access</div>
                        <div class="point">Stack ‚Üí LIFO (Last In First Out), Push/Pop operations</div>
                        <div class="point">Queue ‚Üí FIFO (First In First Out), Enqueue/Dequeue</div>
                        <div class="point">Linked List ‚Üí Dynamic, nodes with pointers (Singly, Doubly, Circular)</div>
                        <div class="point">Hashing ‚Üí Key-value mapping, O(1) average search</div>
                    </div>
                </div>
            </div>
            
            <!-- Section 1: Arrays -->
            <div class="section">
                <div class="section-title">1. Arrays</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>What is an Array?</strong><br>
                        An array is a collection of elements of the same data type stored in contiguous memory locations. Each element can be accessed using an index.
                    </div>
                    
                    <div class="example-box">
                        <strong>Real-life Example:</strong><br>
                        Think of a row of lockers in school. Each locker has a number (index) and stores items (data). You can directly go to locker #5 without checking lockers 1-4.
                    </div>
                    
                    <div class="subsection-title">Characteristics:</div>
                    <div class="advantage-box">
                        ‚úì <strong>Fixed Size:</strong> Size must be declared at creation<br>
                        ‚úì <strong>Random Access:</strong> Access any element in O(1) time<br>
                        ‚úì <strong>Contiguous Memory:</strong> Elements stored in consecutive locations<br>
                        ‚úì <strong>Same Data Type:</strong> All elements must be of same type
                    </div>
                    
                    <div class="code-box"><strong>Time Complexity:</strong>

Operation          | Time Complexity
------------------ | ---------------
Access (by index)  | O(1)
Search             | O(n)
Insert (at end)    | O(1)
Insert (at middle) | O(n)
Delete             | O(n)</div>
                    
                    <div class="note-box">
                        <strong>Key Points:</strong><br>
                        ‚Ä¢ Index starts from 0<br>
                        ‚Ä¢ arr[i] gives element at index i<br>
                        ‚Ä¢ Memory address: base_address + (i √ó size_of_element)
                    </div>
                </div>
            </div>
            
            <!-- Section 2: Stacks -->
            <div class="section">
                <div class="section-title">2. Stacks</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>What is a Stack?</strong><br>
                        A stack is a linear data structure that follows the <strong>LIFO (Last In First Out)</strong> principle. The last element inserted is the first one to be removed.
                    </div>
                    
                    <div class="example-box">
                        <strong>Real-life Examples:</strong><br>
                        ‚Ä¢ Stack of plates: You add/remove from the top only<br>
                        ‚Ä¢ Undo operation in editors: Last action is undone first<br>
                        ‚Ä¢ Browser back button: Last page visited is shown first
                    </div>
                    
                    <div class="subsection-title">Basic Operations:</div>
                    <div class="step-box">
                        <strong>1. Push:</strong> Add element to top of stack<br>
                        <strong>2. Pop:</strong> Remove element from top of stack<br>
                        <strong>3. Peek/Top:</strong> View top element without removing<br>
                        <strong>4. isEmpty:</strong> Check if stack is empty<br>
                        <strong>5. isFull:</strong> Check if stack is full (for fixed-size arrays)
                    </div>
                    
                    <div class="code-box"><strong>Stack Operations - Pseudocode:</strong>

Push(item):
    if stack is full:
        return "Stack Overflow"
    else:
        top = top + 1
        stack[top] = item

Pop():
    if stack is empty:
        return "Stack Underflow"
    else:
        item = stack[top]
        top = top - 1
        return item

Peek():
    if stack is empty:
        return "Stack is empty"
    else:
        return stack[top]</div>
                    
                    <div class="code-box"><strong>Time Complexity:</strong>

Operation | Time
--------- | ----
Push      | O(1)
Pop       | O(1)
Peek      | O(1)
Search    | O(n)</div>
                    
                    <div class="example-box">
                        <strong>Applications of Stack:</strong><br>
                        ‚Ä¢ Function call management (recursion)<br>
                        ‚Ä¢ Expression evaluation (infix to postfix)<br>
                        ‚Ä¢ Backtracking algorithms<br>
                        ‚Ä¢ Undo/Redo operations<br>
                        ‚Ä¢ Syntax parsing
                    </div>
                </div>
            </div>
            
            <!-- Section 3: Queues -->
            <div class="section">
                <div class="section-title">3. Queues</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>What is a Queue?</strong><br>
                        A queue is a linear data structure that follows the <strong>FIFO (First In First Out)</strong> principle. The first element inserted is the first one to be removed.
                    </div>
                    
                    <div class="example-box">
                        <strong>Real-life Examples:</strong><br>
                        ‚Ä¢ Line at ticket counter: First person in line is served first<br>
                        ‚Ä¢ Print queue: First document sent is printed first<br>
                        ‚Ä¢ CPU scheduling: Processes wait in queue
                    </div>
                    
                    <div class="subsection-title">Basic Operations:</div>
                    <div class="step-box">
                        <strong>1. Enqueue:</strong> Add element to rear (back) of queue<br>
                        <strong>2. Dequeue:</strong> Remove element from front of queue<br>
                        <strong>3. Front:</strong> View front element without removing<br>
                        <strong>4. Rear:</strong> View last element<br>
                        <strong>5. isEmpty:</strong> Check if queue is empty
                    </div>
                    
                    <div class="code-box"><strong>Queue Operations - Pseudocode:</strong>

Enqueue(item):
    if queue is full:
        return "Queue Overflow"
    else:
        rear = rear + 1
        queue[rear] = item

Dequeue():
    if queue is empty:
        return "Queue Underflow"
    else:
        item = queue[front]
        front = front + 1
        return item</div>
                    
                    <div class="code-box"><strong>Time Complexity:</strong>

Operation | Time
--------- | ----
Enqueue   | O(1)
Dequeue   | O(1)
Front     | O(1)
Search    | O(n)</div>
                    
                    <div class="example-box">
                        <strong>Applications of Queue:</strong><br>
                        ‚Ä¢ CPU scheduling<br>
                        ‚Ä¢ Printer spooling<br>
                        ‚Ä¢ BFS (Breadth-First Search) in graphs<br>
                        ‚Ä¢ Handling requests in web servers<br>
                        ‚Ä¢ Call center systems
                    </div>
                </div>
            </div>
            
            <!-- Section 4: Pointers -->
            <div class="section">
                <div class="section-title">4. Pointers</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>What is a Pointer?</strong><br>
                        A pointer is a variable that stores the memory address of another variable. It "points to" the location where data is stored.
                    </div>
                    
                    <div class="example-box">
                        <strong>Real-life Example:</strong><br>
                        Think of a pointer as a sticky note with an address written on it. The note doesn't contain your friend's house, but it tells you where to find it.
                    </div>
                    
                    <div class="code-box"><strong>Pointer Basics:</strong>

int x = 10;         // Normal variable
int *ptr = &x;      // Pointer storing address of x

// &x gives address of x
// *ptr gives value at address (dereferencing)

printf("%d", x);     // Prints 10
printf("%d", *ptr);  // Prints 10 (value at address)
printf("%p", ptr);   // Prints address</div>
                    
                    <div class="note-box">
                        <strong>Why Pointers?</strong><br>
                        ‚Ä¢ Dynamic memory allocation<br>
                        ‚Ä¢ Implement linked lists, trees, graphs<br>
                        ‚Ä¢ Pass large structures efficiently<br>
                        ‚Ä¢ Enable call by reference
                    </div>
                </div>
            </div>
            
            <!-- Section 5: Linked Lists -->
            <div class="section">
                <div class="section-title">5. Linked Lists</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>What is a Linked List?</strong><br>
                        A linked list is a linear data structure where elements (nodes) are connected using pointers. Each node contains data and a pointer to the next node.
                    </div>
                    
                    <div class="example-box">
                        <strong>Real-life Example:</strong><br>
                        Think of a treasure hunt where each clue points to the next location. You follow the chain of clues to reach the treasure.
                    </div>
                    
                    <div class="subsection-title">Node Structure:</div>
                    <div class="code-box"><strong>Basic Node:</strong>

struct Node {
    int data;          // Data part
    struct Node* next; // Pointer to next node
};</div>
                    
                    <div class="subsection-title">Types of Linked Lists:</div>
                    
                    <div class="definition-box">
                        <strong>1. Singly Linked List (One-way)</strong><br>
                        Each node points to the next node only. Traversal possible in one direction (forward only).
                    </div>
                    
                    <div class="code-box"><strong>Singly Linked List Structure:</strong>

[Data|Next] ‚Üí [Data|Next] ‚Üí [Data|Next] ‚Üí NULL

Example:
10 ‚Üí 20 ‚Üí 30 ‚Üí NULL

Operations:
- Insert at beginning: O(1)
- Insert at end: O(n)
- Delete: O(n)
- Search: O(n)</div>
                    
                    <div class="definition-box">
                        <strong>2. Doubly Linked List (Two-way)</strong><br>
                        Each node has two pointers: one to the next node and one to the previous node. Traversal possible in both directions.
                    </div>
                    
                    <div class="code-box"><strong>Doubly Linked List Structure:</strong>

NULL ‚Üê [Prev|Data|Next] ‚Üî [Prev|Data|Next] ‚Üî [Prev|Data|Next] ‚Üí NULL

Example:
NULL ‚Üê 10 ‚Üî 20 ‚Üî 30 ‚Üí NULL

Node Structure:
struct Node {
    int data;
    struct Node* prev;
    struct Node* next;
};

Advantages:
- Backward traversal possible
- Delete operation easier (no need to track previous node)

Disadvantages:
- Extra memory for prev pointer
- More complex insertion/deletion</code></div>
                    
                    <div class="definition-box">
                        <strong>3. Circular Linked List (Two-way Circular)</strong><br>
                        Last node points back to the first node, forming a circle. Can be singly or doubly linked.
                    </div>
                    
                    <div class="code-box"><strong>Circular Linked List:</strong>

Singly Circular:
[Data|Next] ‚Üí [Data|Next] ‚Üí [Data|Next] ‚§∂ (back to first)

Doubly Circular:
‚Üî [Prev|Data|Next] ‚Üî [Prev|Data|Next] ‚Üî [Prev|Data|Next] ‚Üî
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Applications:
- Round-robin scheduling
- Music playlist (loop mode)
- Multiplayer games (turn rotation)</code></div>
                    
                    <div class="code-box"><strong>Comparison Table:</strong>

Feature          | Singly      | Doubly       | Circular
---------------- | ----------- | ------------ | --------
Pointers per node| 1           | 2            | 1 or 2
Traversal        | One way     | Both ways    | Circular
Memory           | Less        | More         | Same as type
Delete operation | O(n)        | O(1)*        | O(n)
Applications     | Simple list | Undo/Redo    | Round-robin

* If node reference is given</code></div>
                    
                    <div class="example-box">
                        <strong>Linked List vs Array:</strong><br><br>
                        
                        <strong>Linked List Advantages:</strong><br>
                        ‚Ä¢ Dynamic size (grow/shrink as needed)<br>
                        ‚Ä¢ Easy insertion/deletion (just change pointers)<br>
                        ‚Ä¢ No memory waste<br><br>
                        
                        <strong>Linked List Disadvantages:</strong><br>
                        ‚Ä¢ No random access (must traverse from head)<br>
                        ‚Ä¢ Extra memory for pointers<br>
                        ‚Ä¢ Cache unfriendly (not contiguous memory)
                    </div>
                </div>
            </div>
            
            <!-- Section 6: Hashing -->
            <div class="section">
                <div class="section-title">6. Hashing</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>What is Hashing?</strong><br>
                        Hashing is a technique to map data of any size to fixed-size values using a hash function. It enables fast data retrieval using keys.
                    </div>
                    
                    <div class="example-box">
                        <strong>Real-life Example:</strong><br>
                        Think of a library. Instead of searching all books, you use a catalog number (hash) to directly find the shelf where the book is located.
                    </div>
                    
                    <div class="subsection-title">Key Concepts:</div>
                    
                    <div class="definition-box">
                        <strong>Hash Function:</strong><br>
                        A function that converts a key into an array index (hash value).<br><br>
                        <strong>Example:</strong> hash(key) = key % table_size
                    </div>
                    
                    <div class="definition-box">
                        <strong>Hash Table:</strong><br>
                        An array where data is stored using hash values as indices.
                    </div>
                    
                    <div class="code-box"><strong>Simple Hashing Example:</strong>

Hash Function: h(key) = key % 10
Table Size: 10

Insert 25: h(25) = 25 % 10 = 5 ‚Üí Store at index 5
Insert 42: h(42) = 42 % 10 = 2 ‚Üí Store at index 2
Insert 15: h(15) = 15 % 10 = 5 ‚Üí Collision! (index 5 occupied)

Hash Table:
Index: 0  1  2   3  4  5   6  7  8  9
Data:  -  - 42   -  - 25   -  -  -  -</code></div>
                    
                    <div class="subsection-title">Collision Handling:</div>
                    <div class="definition-box">
                        <strong>What is Collision?</strong><br>
                        When two different keys hash to the same index, it's called a collision.
                    </div>
                    
                    <div class="step-box">
                        <strong>Collision Resolution Methods:</strong><br><br>
                        
                        <strong>1. Chaining:</strong><br>
                        Store multiple elements at same index using linked list<br><br>
                        
                        <strong>2. Open Addressing:</strong><br>
                        Find another empty slot in the table<br>
                        ‚Ä¢ Linear Probing: Check next slot (i+1, i+2, ...)<br>
                        ‚Ä¢ Quadratic Probing: Check i+1¬≤, i+2¬≤, ...<br>
                        ‚Ä¢ Double Hashing: Use second hash function
                    </div>
                    
                    <div class="code-box"><strong>Time Complexity:</strong>

Operation       | Average | Worst Case
--------------- | ------- | ----------
Search          | O(1)    | O(n)
Insert          | O(1)    | O(n)
Delete          | O(1)    | O(n)

Note: Worst case occurs with many collisions</code></div>
                    
                    <div class="example-box">
                        <strong>Applications of Hashing:</strong><br>
                        ‚Ä¢ Dictionaries (key-value pairs)<br>
                        ‚Ä¢ Database indexing<br>
                        ‚Ä¢ Caches (browser cache, CPU cache)<br>
                        ‚Ä¢ Password storage (hash passwords)<br>
                        ‚Ä¢ Cryptography (checksums, digital signatures)
                    </div>
                    
                    <div class="note-box">
                        <strong>Good Hash Function Properties:</strong><br>
                        ‚Ä¢ Deterministic (same input ‚Üí same output)<br>
                        ‚Ä¢ Uniform distribution (minimize collisions)<br>
                        ‚Ä¢ Fast to compute<br>
                        ‚Ä¢ Minimize clustering
                    </div>
                </div>
            </div>
            
            <div class="divider"></div>
            <!-- Section 7: Trees -->
            <div class="section">
                <div class="section-title">7. Trees</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>What is a Tree?</strong><br>
                        A tree is a hierarchical data structure consisting of nodes connected by edges. It has a root node and every other node is connected by exactly one path from the root.
                    </div>
                    
                    <div class="example-box">
                        <strong>Real-life Examples:</strong><br>
                        ‚Ä¢ Family tree (genealogy)<br>
                        ‚Ä¢ Organization chart (company hierarchy)<br>
                        ‚Ä¢ File system (folders and files)<br>
                        ‚Ä¢ Decision trees
                    </div>
                    
                    <div class="subsection-title">Tree Terminology:</div>
                    <div class="step-box">
                        <strong>Root:</strong> Top node (no parent)<br>
                        <strong>Parent:</strong> Node with children<br>
                        <strong>Child:</strong> Node connected below parent<br>
                        <strong>Leaf:</strong> Node with no children<br>
                        <strong>Height:</strong> Longest path from root to leaf<br>
                        <strong>Depth:</strong> Distance from root to node<br>
                        <strong>Degree:</strong> Number of children of a node
                    </div>
                    
                    <div class="subsection-title">Binary Search Tree (BST)</div>
                    <div class="definition-box">
                        <strong>What is BST?</strong><br>
                        A Binary Search Tree is a binary tree where:<br>
                        ‚Ä¢ Left subtree contains values less than parent<br>
                        ‚Ä¢ Right subtree contains values greater than parent<br>
                        ‚Ä¢ Both left and right subtrees are also BSTs
                    </div>
                    
                    <div class="code-box"><strong>BST Example:</strong>

         50
        /  \
      30    70
     / \    / \
   20  40 60  80

Properties:
- All nodes in left subtree < 50
- All nodes in right subtree > 50
- Inorder traversal gives sorted order: 20,30,40,50,60,70,80</code></div>
                    
                    <div class="code-box"><strong>BST Operations - Time Complexity:</strong>

Operation       | Average    | Worst Case
--------------- | ---------- | ----------
Search          | O(log n)   | O(n)
Insert          | O(log n)   | O(n)
Delete          | O(log n)   | O(n)

Worst case: When tree becomes skewed (like linked list)
Example: Inserting 10,20,30,40,50 in order creates right-skewed tree</code></div>
                    
                    <div class="example-box">
                        <strong>BST Search Example:</strong><br>
                        Search for 60 in the tree above:<br>
                        1. Start at root (50): 60 > 50, go right<br>
                        2. At 70: 60 < 70, go left<br>
                        3. Found 60! ‚Üí 2 comparisons<br><br>
                        Much faster than linear search (would need 5 comparisons)
                    </div>
                    
                    <div class="subsection-title">B-Tree</div>
                    <div class="definition-box">
                        <strong>What is B-Tree?</strong><br>
                        A B-Tree is a self-balancing tree where each node can have multiple keys and children. It's optimized for systems that read/write large blocks of data (like databases).
                    </div>
                    
                    <div class="step-box">
                        <strong>B-Tree Properties (order m):</strong><br>
                        ‚Ä¢ Each node has at most m children<br>
                        ‚Ä¢ Each node (except root) has at least m/2 children<br>
                        ‚Ä¢ Root has at least 2 children (unless it's a leaf)<br>
                        ‚Ä¢ All leaves are at the same level<br>
                        ‚Ä¢ Keys in a node are sorted
                    </div>
                    
                    <div class="example-box">
                        <strong>Why B-Trees?</strong><br>
                        ‚Ä¢ Used in databases and file systems<br>
                        ‚Ä¢ Minimize disk I/O operations<br>
                        ‚Ä¢ Keep tree height low (balanced)<br>
                        ‚Ä¢ Efficient for large datasets<br><br>
                        
                        <strong>Applications:</strong> MySQL databases, file systems (NTFS, ext4)
                    </div>
                    
                    <div class="subsection-title">Balanced Trees (AVL & Red-Black Trees)</div>
                    <div class="definition-box">
                        <strong>What are Balanced Trees?</strong><br>
                        Balanced trees are self-balancing BSTs that maintain O(log n) height, ensuring efficient operations even in worst case.
                    </div>
                    
                    <div class="definition-box">
                        <strong>AVL Tree:</strong><br>
                        A self-balancing BST where the height difference between left and right subtrees (balance factor) is at most 1 for every node.<br><br>
                        <strong>Balance Factor:</strong> height(left subtree) - height(right subtree)<br>
                        Allowed values: -1, 0, 1
                    </div>
                    
                    <div class="code-box"><strong>AVL Tree Operations:</strong>

When balance factor becomes > 1 or < -1:
Perform rotations to rebalance:

1. Left Rotation (LL)
2. Right Rotation (RR)
3. Left-Right Rotation (LR)
4. Right-Left Rotation (RL)

Time Complexity:
Search: O(log n) - GUARANTEED
Insert: O(log n)
Delete: O(log n)</code></div>
                    
                    <div class="definition-box">
                        <strong>Red-Black Tree:</strong><br>
                        A self-balancing BST where each node has a color (red or black) with specific properties maintained.
                    </div>
                    
                    <div class="step-box">
                        <strong>Red-Black Tree Properties:</strong><br>
                        1. Every node is either red or black<br>
                        2. Root is always black<br>
                        3. All leaves (NULL) are black<br>
                        4. Red node cannot have red children<br>
                        5. All paths from root to leaves have same number of black nodes
                    </div>
                    
                    <div class="code-box"><strong>AVL vs Red-Black Tree:</strong>

Feature          | AVL Tree        | Red-Black Tree
---------------- | --------------- | ---------------
Balance          | Strictly balanced| Less strict
Height           | Lower height    | Slightly higher
Search           | Faster          | Slightly slower
Insert/Delete    | More rotations  | Fewer rotations
Use Case         | Search-heavy    | Insert/Delete-heavy

Examples:
AVL: Databases with frequent lookups
Red-Black: Java TreeMap, Linux kernel</code></div>
                    
                    <div class="example-box">
                        <strong>When to Use Which Tree?</strong><br><br>
                        
                        <strong>BST:</strong> Simple applications, small datasets<br>
                        <strong>AVL:</strong> Frequent searches, read-heavy operations<br>
                        <strong>Red-Black:</strong> Frequent insertions/deletions<br>
                        <strong>B-Tree:</strong> Large datasets, databases, file systems
                    </div>
                </div>
            </div>
            
            <!-- Section 8: Heaps -->
            <div class="section">
                <div class="section-title">8. Heaps</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>What is a Heap?</strong><br>
                        A heap is a complete binary tree that satisfies the heap property. It's primarily used for priority queues and heap sort.
                    </div>
                    
                    <div class="subsection-title">Types of Heaps:</div>
                    
                    <div class="definition-box">
                        <strong>1. Max Heap:</strong><br>
                        Parent node is always greater than or equal to its children.<br>
                        Root contains the maximum element.
                    </div>
                    
                    <div class="code-box"><strong>Max Heap Example:</strong>

         100
        /   \
      80     90
     / \    / \
   70  60 50  40

Property: Parent ‚â• Children
Root (100) is the maximum element</code></div>
                    
                    <div class="definition-box">
                        <strong>2. Min Heap:</strong><br>
                        Parent node is always less than or equal to its children.<br>
                        Root contains the minimum element.
                    </div>
                    
                    <div class="code-box"><strong>Min Heap Example:</strong>

         10
        /  \
      20    30
     / \    / \
   40  50 60  70

Property: Parent ‚â§ Children
Root (10) is the minimum element</code></div>
                    
                    <div class="subsection-title">Heap Operations:</div>
                    <div class="step-box">
                        <strong>1. Insert:</strong><br>
                        ‚Ä¢ Add element at the end (bottom-right)<br>
                        ‚Ä¢ Heapify up (swap with parent if needed)<br>
                        Time: O(log n)<br><br>
                        
                        <strong>2. Delete (Extract Max/Min):</strong><br>
                        ‚Ä¢ Remove root element<br>
                        ‚Ä¢ Replace root with last element<br>
                        ‚Ä¢ Heapify down (swap with larger/smaller child)<br>
                        Time: O(log n)<br><br>
                        
                        <strong>3. Get Max/Min:</strong><br>
                        ‚Ä¢ Simply return root<br>
                        Time: O(1)
                    </div>
                    
                    <div class="code-box"><strong>Heap Implementation:</strong>

Heaps are usually stored in arrays:
For node at index i:
- Left child: 2i + 1
- Right child: 2i + 2
- Parent: (i - 1) / 2

Example (Max Heap):
Array: [100, 80, 90, 70, 60, 50, 40]
Index:   0   1   2   3   4   5   6

         100(0)
        /      \
      80(1)    90(2)
     /   \     /   \
   70(3) 60(4) 50(5) 40(6)</code></div>
                    
                    <div class="example-box">
                        <strong>Applications of Heaps:</strong><br>
                        ‚Ä¢ Priority Queue implementation<br>
                        ‚Ä¢ Heap Sort algorithm<br>
                        ‚Ä¢ Dijkstra's shortest path algorithm<br>
                        ‚Ä¢ Finding k largest/smallest elements<br>
                        ‚Ä¢ Median maintenance in streaming data
                    </div>
                    
                    <div class="code-box"><strong>Time Complexity Summary:</strong>

Operation       | Time Complexity
--------------- | ---------------
Build Heap      | O(n)
Insert          | O(log n)
Delete Max/Min  | O(log n)
Get Max/Min     | O(1)
Heapify         | O(log n)</code></div>
                </div>
            </div>
            
            <!-- Section 9: Graphs -->
            <div class="section">
                <div class="section-title">9. Graphs</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>What is a Graph?</strong><br>
                        A graph is a non-linear data structure consisting of vertices (nodes) and edges (connections). It represents relationships between objects.
                    </div>
                    
                    <div class="example-box">
                        <strong>Real-life Examples:</strong><br>
                        ‚Ä¢ Social networks (Facebook friends)<br>
                        ‚Ä¢ Road networks (cities connected by roads)<br>
                        ‚Ä¢ Internet (web pages connected by links)<br>
                        ‚Ä¢ Flight routes (airports and flights)
                    </div>
                    
                    <div class="subsection-title">Graph Terminology:</div>
                    <div class="step-box">
                        <strong>Vertex (Node):</strong> A point in the graph<br>
                        <strong>Edge:</strong> Connection between two vertices<br>
                        <strong>Adjacent:</strong> Two vertices connected by an edge<br>
                        <strong>Degree:</strong> Number of edges connected to a vertex<br>
                        <strong>Path:</strong> Sequence of vertices connected by edges<br>
                        <strong>Cycle:</strong> Path that starts and ends at same vertex
                    </div>
                    
                    <div class="subsection-title">Types of Graphs:</div>
                    
                    <div class="definition-box">
                        <strong>1. Directed Graph (Digraph):</strong><br>
                        Edges have direction (one-way). A‚ÜíB is different from B‚ÜíA.
                    </div>
                    
                    <div class="code-box"><strong>Directed Graph Example:</strong>

A ‚Üí B
‚Üì   ‚Üì
C ‚Üê D

Edge (A,B) means you can go from A to B
But cannot go from B to A (unless there's B‚ÜíA edge)</code></div>
                    
                    <div class="definition-box">
                        <strong>2. Undirected Graph:</strong><br>
                        Edges have no direction (two-way). A-B means you can go both ways.
                    </div>
                    
                    <div class="code-box"><strong>Undirected Graph Example:</strong>

A ‚Äî B
|   |
C ‚Äî D

Edge (A,B) allows travel in both directions</code></div>
                    
                    <div class="definition-box">
                        <strong>3. Weighted Graph:</strong><br>
                        Edges have weights (costs/distances).
                    </div>
                    
                    <div class="code-box"><strong>Weighted Graph Example:</strong>

    5        3
A ---- B ---- C
 \          /
  10      7
   \    /
     D

Used for: Shortest path problems, network routing</code></div>
                    
                    <div class="subsection-title">Graph Representation:</div>
                    
                    <div class="definition-box">
                        <strong>1. Adjacency Matrix:</strong><br>
                        2D array where matrix[i][j] = 1 if edge exists between vertex i and j.
                    </div>
                    
                    <div class="code-box"><strong>Adjacency Matrix Example:</strong>

Graph:
0 ‚Äî 1
|   |
2 ‚Äî 3

Matrix:
    0  1  2  3
0 [ 0  1  1  0 ]
1 [ 1  0  0  1 ]
2 [ 1  0  0  1 ]
3 [ 0  1  1  0 ]

Space: O(V¬≤)
Check edge: O(1)
Find neighbors: O(V)</code></div>
                    
                    <div class="definition-box">
                        <strong>2. Adjacency List:</strong><br>
                        Array of lists. Each vertex has a list of its adjacent vertices.
                    </div>
                    
                    <div class="code-box"><strong>Adjacency List Example:</strong>

Graph:
0 ‚Äî 1
|   |
2 ‚Äî 3

List:
0: [1, 2]
1: [0, 3]
2: [0, 3]
3: [1, 2]

Space: O(V + E)
Check edge: O(degree)
Find neighbors: O(degree)

Better for sparse graphs!</code></div>
                    
                    <div class="code-box"><strong>Adjacency Matrix vs List:</strong>

Feature         | Matrix      | List
--------------- | ----------- | -----------
Space           | O(V¬≤)       | O(V + E)
Add edge        | O(1)        | O(1)
Remove edge     | O(1)        | O(V)
Check edge      | O(1)        | O(degree)
Find neighbors  | O(V)        | O(degree)

Use Matrix: Dense graphs, frequent edge checks
Use List: Sparse graphs, less memory</code></div>
                    
                    <div class="subsection-title">Graph Traversal:</div>
                    
                    <div class="definition-box">
                        <strong>1. BFS (Breadth-First Search):</strong><br>
                        Visit all neighbors at current level before moving to next level. Uses Queue.
                    </div>
                    
                    <div class="code-box"><strong>BFS Algorithm:</strong>

1. Start from source vertex
2. Mark it visited, add to queue
3. While queue not empty:
   - Remove vertex from queue
   - Visit all unvisited neighbors
   - Mark them visited, add to queue

Time: O(V + E)
Space: O(V)

Applications: Shortest path in unweighted graph, level-order traversal</code></div>
                    
                    <div class="definition-box">
                        <strong>2. DFS (Depth-First Search):</strong><br>
                        Go as deep as possible along each branch before backtracking. Uses Stack/Recursion.
                    </div>
                    
                    <div class="code-box"><strong>DFS Algorithm:</strong>

1. Start from source vertex
2. Mark it visited
3. Recursively visit all unvisited neighbors

Time: O(V + E)
Space: O(V)

Applications: Cycle detection, topological sorting, maze solving</code></div>
                    
                    <div class="example-box">
                        <strong>BFS vs DFS:</strong><br><br>
                        
                        <strong>Use BFS when:</strong><br>
                        ‚Ä¢ Finding shortest path<br>
                        ‚Ä¢ Level-by-level exploration needed<br>
                        ‚Ä¢ Solution is near source<br><br>
                        
                        <strong>Use DFS when:</strong><br>
                        ‚Ä¢ Need to visit all nodes<br>
                        ‚Ä¢ Detecting cycles<br>
                        ‚Ä¢ Topological sorting<br>
                        ‚Ä¢ Solution is far from source
                    </div>
                    
                    <div class="example-box">
                        <strong>Common Graph Applications:</strong><br>
                        ‚Ä¢ Google Maps (shortest path - Dijkstra's algorithm)<br>
                        ‚Ä¢ Social Network Analysis (friend recommendations)<br>
                        ‚Ä¢ Web Crawling (DFS to explore websites)<br>
                        ‚Ä¢ Dependency Resolution (topological sort)<br>
                        ‚Ä¢ Network Flow (maximum flow problems)
                    </div>
                </div>
            </div>
            
            <div class="divider"></div>
            <!-- CHAPTER 4: SORTING ALGORITHMS -->
            <div class="chapter-title" id="ch4">
                <span>üî¢</span>
                <span>Chapter 4 ‚Äî Sorting in Linear Time</span>
            </div>
            
            <!-- Section 1: Introduction -->
            <div class="section">
                <div class="section-title">1. Linear Time Sorting Algorithms</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>What is Linear Time Sorting?</strong><br>
                        Sorting algorithms that can sort in O(n) or O(n+k) time, faster than comparison-based sorts (O(n log n) lower bound).
                    </div>
                    
                    <div class="note-box">
                        <strong>Key Difference:</strong><br>
                        ‚Ä¢ Comparison sorts: Compare elements (Merge Sort, Quick Sort) ‚Üí O(n log n)<br>
                        ‚Ä¢ Non-comparison sorts: Use different approach (Counting, Radix, Bucket) ‚Üí O(n)
                    </div>
                </div>
            </div>
            
            <!-- Section 2: Counting Sort -->
            <div class="section">
                <div class="section-title">2. Counting Sort</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>What is Counting Sort?</strong><br>
                        Counting Sort counts the occurrences of each element and uses this information to place elements in sorted order. Works well when range of input is small.
                    </div>
                    
                    <div class="code-box"><strong>Algorithm Steps:</strong>

1. Find the range (max - min)
2. Create count array of size (max + 1)
3. Count occurrences of each element
4. Modify count array to store cumulative sum
5. Place elements in output array using count array
6. Copy output to original array

Time Complexity: O(n + k) where k is range
Space Complexity: O(k)</code></div>
                    
                    <div class="example-box">
                        <strong>Example: Sort [4, 2, 2, 8, 3, 3, 1]</strong><br><br>
                        
                        <strong>Step 1:</strong> Count occurrences<br>
                        Count array: [0, 1, 2, 2, 1, 0, 0, 0, 1]<br>
                        Index:       [0, 1, 2, 3, 4, 5, 6, 7, 8]<br><br>
                        
                        <strong>Step 2:</strong> Cumulative sum<br>
                        Count array: [0, 1, 3, 5, 6, 6, 6, 6, 7]<br><br>
                        
                        <strong>Step 3:</strong> Place elements<br>
                        Output: [1, 2, 2, 3, 3, 4, 8]<br><br>
                        
                        <strong>Result:</strong> Sorted in O(n + k) time!
                    </div>
                    
                    <div class="advantage-box">
                        <strong>Advantages:</strong><br>
                        ‚úì Linear time O(n + k)<br>
                        ‚úì Stable sorting (maintains relative order)<br>
                        ‚úì Simple to implement<br><br>
                        
                        <strong>Disadvantages:</strong><br>
                        ‚úó Not suitable for large range (k >> n)<br>
                        ‚úó Requires extra space O(k)<br>
                        ‚úó Only works with integers
                    </div>
                    
                    <div class="example-box">
                        <strong>When to Use Counting Sort?</strong><br>
                        ‚Ä¢ Small range of integers<br>
                        ‚Ä¢ Need stable sort<br>
                        ‚Ä¢ Example: Sorting ages (0-100), grades (0-100)
                    </div>
                </div>
            </div>
            
            <!-- Section 3: Radix Sort -->
            <div class="section">
                <div class="section-title">3. Radix Sort</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>What is Radix Sort?</strong><br>
                        Radix Sort sorts numbers digit by digit, starting from least significant digit (LSD) to most significant digit (MSD). Uses Counting Sort as subroutine.
                    </div>
                    
                    <div class="code-box"><strong>Algorithm Steps:</strong>

1. Find the maximum number to know number of digits
2. Starting from least significant digit:
   - Sort elements based on current digit using Counting Sort
   - Move to next digit
3. Repeat until all digits processed

Time Complexity: O(d √ó (n + k))
  where d = number of digits, k = range (usually 10 for decimal)
Space Complexity: O(n + k)</code></div>
                    
                    <div class="example-box">
                        <strong>Example: Sort [170, 45, 75, 90, 802, 24, 2, 66]</strong><br><br>
                        
                        Max = 802 (3 digits), so d = 3<br><br>
                        
                        <strong>Pass 1 (Ones place):</strong><br>
                        Sort by last digit: 0, 2, 4, 5, 6, 0, 2, 5<br>
                        Result: [170, 90, 802, 2, 24, 45, 75, 66]<br><br>
                        
                        <strong>Pass 2 (Tens place):</strong><br>
                        Sort by middle digit: 7, 9, 0, 0, 2, 4, 7, 6<br>
                        Result: [802, 2, 24, 45, 66, 170, 75, 90]<br><br>
                        
                        <strong>Pass 3 (Hundreds place):</strong><br>
                        Sort by first digit: 8, 0, 0, 0, 0, 1, 0, 0<br>
                        <strong>Final Result: [2, 24, 45, 66, 75, 90, 170, 802]</strong>
                    </div>
                    
                    <div class="advantage-box">
                        <strong>Advantages:</strong><br>
                        ‚úì Fast for numbers with fixed number of digits<br>
                        ‚úì Stable sorting<br>
                        ‚úì Better than comparison sorts for large datasets<br><br>
                        
                        <strong>Disadvantages:</strong><br>
                        ‚úó Slower for small datasets<br>
                        ‚úó Requires stable sort as subroutine<br>
                        ‚úó Not in-place (needs extra space)
                    </div>
                    
                    <div class="example-box">
                        <strong>When to Use Radix Sort?</strong><br>
                        ‚Ä¢ Large list of integers<br>
                        ‚Ä¢ Fixed number of digits<br>
                        ‚Ä¢ Example: Sorting phone numbers, student IDs, ZIP codes
                    </div>
                </div>
            </div>
            
            <!-- Section 4: Bucket Sort -->
            <div class="section">
                <div class="section-title">4. Bucket Sort</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>What is Bucket Sort?</strong><br>
                        Bucket Sort distributes elements into several buckets, sorts each bucket individually, then concatenates all buckets. Works well for uniformly distributed data.
                    </div>
                    
                    <div class="code-box"><strong>Algorithm Steps:</strong>

1. Create n empty buckets
2. Distribute elements into buckets based on range
3. Sort each bucket individually (using insertion sort)
4. Concatenate all buckets in order

Time Complexity:
  Average: O(n + k) where k is number of buckets
  Worst: O(n¬≤) when all elements go to one bucket
Space Complexity: O(n + k)</code></div>
                    
                    <div class="example-box">
                        <strong>Example: Sort [0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12]</strong><br><br>
                        
                        Assume 5 buckets (range 0-1)<br><br>
                        
                        <strong>Step 1: Distribute to buckets</strong><br>
                        Bucket 0 [0.0-0.2]: [0.17, 0.12]<br>
                        Bucket 1 [0.2-0.4]: [0.26, 0.21, 0.39]<br>
                        Bucket 2 [0.4-0.6]: []<br>
                        Bucket 3 [0.6-0.8]: [0.78, 0.72]<br>
                        Bucket 4 [0.8-1.0]: [0.94]<br><br>
                        
                        <strong>Step 2: Sort each bucket</strong><br>
                        Bucket 0: [0.12, 0.17]<br>
                        Bucket 1: [0.21, 0.26, 0.39]<br>
                        Bucket 2: []<br>
                        Bucket 3: [0.72, 0.78]<br>
                        Bucket 4: [0.94]<br><br>
                        
                        <strong>Step 3: Concatenate</strong><br>
                        <strong>Final: [0.12, 0.17, 0.21, 0.26, 0.39, 0.72, 0.78, 0.94]</strong>
                    </div>
                    
                    <div class="advantage-box">
                        <strong>Advantages:</strong><br>
                        ‚úì Fast for uniformly distributed data<br>
                        ‚úì Simple to understand<br>
                        ‚úì Can use any sorting algorithm for buckets<br><br>
                        
                        <strong>Disadvantages:</strong><br>
                        ‚úó Performance depends on distribution<br>
                        ‚úó Extra space required<br>
                        ‚úó Not efficient for large ranges
                    </div>
                    
                    <div class="example-box">
                        <strong>When to Use Bucket Sort?</strong><br>
                        ‚Ä¢ Data is uniformly distributed<br>
                        ‚Ä¢ Floating point numbers in range<br>
                        ‚Ä¢ Example: Sorting decimal numbers, histogram data
                    </div>
                </div>
            </div>
            
            <!-- Section 5: Comparison -->
            <div class="section">
                <div class="section-title">5. Sorting Algorithms Comparison</div>
                <div class="content">
                    <div class="code-box"><strong>Complete Comparison Table:</strong>

Algorithm      | Time (Avg) | Time (Worst) | Space  | Stable | Use Case
-------------- | ---------- | ------------ | ------ | ------ | --------
Counting Sort  | O(n+k)     | O(n+k)       | O(k)   | Yes    | Small range
Radix Sort     | O(d(n+k))  | O(d(n+k))    | O(n+k) | Yes    | Fixed digits
Bucket Sort    | O(n+k)     | O(n¬≤)        | O(n)   | Yes    | Uniform data
Merge Sort     | O(n log n) | O(n log n)   | O(n)   | Yes    | General
Quick Sort     | O(n log n) | O(n¬≤)        | O(log n)| No    | General
Heap Sort      | O(n log n) | O(n log n)   | O(1)   | No     | In-place

Key: k = range, d = digits, n = elements</code></div>
                </div>
            </div>
            
        </div>
        
        <!-- LAST MIN NOTES TAB -->
        <div class="tab-content" id="lastMinTab">
            <div class="chapter-title">
                <span>‚ö°</span>
                <span>Last Minute Notes - Quick Revision (5-10 mins)</span>
            </div>
            
            <!-- Quick Tips -->
            <div class="section">
                <div class="note-box">
                    <strong>üìå How to Use:</strong> Read this 5-10 minutes before exam. Contains all formulas, key concepts, and commonly asked topics in condensed form.
                </div>
            </div>
            
            <!-- Complexity -->
            <div class="section">
                <div class="section-title">‚è±Ô∏è Time & Space Complexity</div>
                <div class="content">
                    <div class="code-box">O(1) < O(log n) < O(n) < O(n log n) < O(n¬≤) < O(2‚Åø) < O(n!)

Remember:
‚Ä¢ Drop constants: O(2n) = O(n)
‚Ä¢ Keep highest: O(n¬≤ + n) = O(n¬≤)
‚Ä¢ Nested loops multiply: O(n) √ó O(n) = O(n¬≤)</code></div>
                </div>
            </div>
            
            <!-- Case Analysis -->
            <div class="section">
                <div class="section-title">üìä Case Analysis</div>
                <div class="content">
                    <div class="step-box">
                        <strong>Best Case (Œ©):</strong> Minimum time (at least)<br>
                        <strong>Average Case (Œò):</strong> Expected time (exactly)<br>
                        <strong>Worst Case (O):</strong> Maximum time (at most)<br><br>
                        Most important: <strong>Worst Case</strong>
                    </div>
                </div>
            </div>
            
            <!-- Asymptotic Notations -->
            <div class="section">
                <div class="section-title">üìà Asymptotic Notations (Very Important!)</div>
                <div class="content">
                    <div class="code-box">Big O (O)     ‚Üí Upper bound (‚â§)
Big Omega (Œ©) ‚Üí Lower bound (‚â•)
Big Theta (Œò) ‚Üí Tight bound (=)

Master Method: T(n) = aT(n/b) + f(n)
Calculate: n^(log_b a)
Case 1: f(n) < ‚Üí Answer: Œò(n^log_b a)
Case 2: f(n) = ‚Üí Answer: Œò(n^log_b a √ó log n)
Case 3: f(n) > ‚Üí Answer: Œò(f(n))</code></div>
                </div>
            </div>
            
            <!-- Recurrence -->
            <div class="section">
                <div class="section-title">üîÑ Recurrence Quick Reference</div>
                <div class="content">
                    <div class="code-box">T(n) = T(n/2) + c      ‚Üí O(log n)    Binary Search
T(n) = 2T(n/2) + n     ‚Üí O(n log n)  Merge Sort
T(n) = T(n-1) + c      ‚Üí O(n)        Linear
T(n) = T(n-1) + n      ‚Üí O(n¬≤)       Quadratic</code></div>
                </div>
            </div>
            
            <!-- Data Structures -->
            <div class="section">
                <div class="section-title">üì¶ Data Structures Cheat Sheet</div>
                <div class="content">
                    <div class="code-box">Stack: LIFO | Push/Pop O(1)
Queue: FIFO | Enqueue/Dequeue O(1)
Array: Random access O(1) | Search O(n)
Linked List: Insert O(1) | Access O(n)
Hash Table: Search O(1) avg | Collision resolution

BST: Search/Insert/Delete O(log n) avg, O(n) worst
AVL: All operations O(log n) guaranteed
Heap: Insert/Delete O(log n) | Get max O(1)</code></div>
                </div>
            </div>
            
            <!-- Trees -->
            <div class="section">
                <div class="section-title">üå≥ Trees Quick Points</div>
                <div class="content">
                    <div class="step-box">
                        <strong>BST:</strong> Left < Parent < Right<br>
                        <strong>AVL:</strong> Balance factor ‚àà {-1, 0, 1}<br>
                        <strong>Red-Black:</strong> Root black, no red-red parent-child<br>
                        <strong>B-Tree:</strong> Multi-way, all leaves same level<br>
                        <strong>Heap:</strong> Max: Parent ‚â• Children, Min: Parent ‚â§ Children
                    </div>
                </div>
            </div>
            
            <!-- Graph -->
            <div class="section">
                <div class="section-title">üï∏Ô∏è Graph Essentials</div>
                <div class="content">
                    <div class="code-box">Representation:
‚Ä¢ Matrix: O(V¬≤) space, O(1) edge check
‚Ä¢ List: O(V+E) space, better for sparse

Traversal:
‚Ä¢ BFS: Queue, level-order, shortest path
‚Ä¢ DFS: Stack/Recursion, deep exploration

Time: Both O(V + E)</code></div>
                </div>
            </div>
            
            <!-- Sorting -->
            <div class="section">
                <div class="section-title">üî¢ Sorting Algorithms</div>
                <div class="content">
                    <div class="code-box">Linear Time (Non-comparison):
Counting: O(n+k) | Small range integers
Radix: O(d(n+k)) | Fixed digit numbers
Bucket: O(n+k) avg | Uniform distribution

Comparison-based: O(n log n) lower bound
Merge: O(n log n) always, Stable
Quick: O(n log n) avg, O(n¬≤) worst
Heap: O(n log n), In-place</code></div>
                </div>
            </div>
            
            <!-- Important Formulas -->
            <div class="section">
                <div class="section-title">üìê Important Formulas</div>
                <div class="content">
                    <div class="formula-box">
                        1 + 2 + 3 + ... + n = n(n+1)/2 = O(n¬≤)
                        
                        1 + 2 + 4 + ... + 2‚Åø = 2‚Åø‚Å∫¬π - 1 = O(2‚Åø)
                        
                        log(ab) = log a + log b
                        
                        log(a·µá) = b log a
                    </formula-box>
                </div>
            </div>
            
            <!-- Common Mistakes -->
            <div class="section">
                <div class="section-title">‚ö†Ô∏è Common Exam Mistakes</div>
                <div class="content">
                    <div class="threat-box">
                        ‚ùå Confusing O with Œ© with Œò<br>
                        ‚ùå Forgetting to drop constants<br>
                        ‚ùå Wrong Master Method case selection<br>
                        ‚ùå Mixing up Stack (LIFO) with Queue (FIFO)<br>
                        ‚ùå BST worst case is O(n), not O(log n)<br>
                        ‚ùå Heap stored in array: left=2i+1, right=2i+2<br>
                        ‚ùå DFS uses stack, BFS uses queue<br>
                        ‚ùå Counting Sort needs small range
                    </div>
                </div>
            </div>
            
            <!-- Must Remember -->
            <div class="section">
                <div class="section-title">üéØ Must Remember for Exam</div>
                <div class="content">
                    <div class="advantage-box">
                        ‚úì Time complexity hierarchy<br>
                        ‚úì Master Theorem 3 cases<br>
                        ‚úì Big O, Omega, Theta definitions<br>
                        ‚úì Stack vs Queue operations<br>
                        ‚úì BST, AVL, Red-Black properties<br>
                        ‚úì BFS vs DFS (when to use)<br>
                        ‚úì Adjacency Matrix vs List<br>
                        ‚úì Counting/Radix/Bucket sort differences<br>
                        ‚úì Array formulas (child/parent in heap)
                    </div>
                </div>
            </div>
            
            <!-- Final Tips -->
            <div class="section">
                <div class="section-title">üí° Exam Strategy</div>
                <div class="content">
                    <div class="example-box">
                        <strong>For Theory Questions:</strong><br>
                        ‚Ä¢ Define clearly<br>
                        ‚Ä¢ Give example<br>
                        ‚Ä¢ Draw diagram if possible<br>
                        ‚Ä¢ Mention time complexity<br><br>
                        
                        <strong>For Algorithm Questions:</strong><br>
                        ‚Ä¢ Write steps clearly<br>
                        ‚Ä¢ Show example<br>
                        ‚Ä¢ Analyze complexity<br>
                        ‚Ä¢ Compare with alternatives<br><br>
                        
                        <strong>Time Management:</strong><br>
                        ‚Ä¢ Start with easy questions<br>
                        ‚Ä¢ Attempt all questions<br>
                        ‚Ä¢ Keep 10 mins for revision
                    </div>
                </div>
            </div>
            
            <!-- Good Luck -->
            <div class="section">
                <div class="note-box" style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.1) 0%, rgba(59, 130, 246, 0.1) 100%); border-left: 4px solid var(--success);">
                    <strong>üåü All the Best!</strong><br>
                    You've covered everything! DAA is about understanding patterns and complexity. Practice different problems, understand the logic, and you'll ace it! Remember: Every algorithm has a purpose. Good luck! üí™üöÄ
                </div>
            </div>
            
        </div>
        
    </div>
    
    <!-- Footer -->
    <div class="footer">
        <div class="footer-credit">
            Made with üíô by <strong>Ankush Raj</strong>
        </div>
        <p class="footer-note">
            ¬© 2026 <a href="https://ankushraj.dev" target="_blank" style="color: var(--primary); text-decoration: none; font-weight: 600;">ankushraj.dev</a> - All Rights Reserved
        </p>
    </div>
    
    <script>
        // Dark Mode Toggle
        const darkModeBtn = document.getElementById('darkModeBtn');
        const isDarkMode = localStorage.getItem('darkMode') === 'true';
        
        if (isDarkMode) {
            document.body.classList.add('dark-mode');
            updateDarkModeBtn(true);
        }
        
        function toggleDarkMode() {
            document.body.classList.toggle('dark-mode');
            const isDark = document.body.classList.contains('dark-mode');
            localStorage.setItem('darkMode', isDark);
            updateDarkModeBtn(isDark);
        }
        
        function updateDarkModeBtn(isDark) {
            const btn = document.getElementById('darkModeBtn');
            btn.innerHTML = isDark 
                ? '<span>‚òÄÔ∏è</span><span>Light</span>' 
                : '<span>üåô</span><span>Dark</span>';
        }
        
        // TOC Toggle
        function openTOC() {
            document.getElementById('tocPanel').classList.add('active');
            document.getElementById('overlay').classList.add('active');
        }
        
        function closeTOC() {
            document.getElementById('tocPanel').classList.remove('active');
            document.getElementById('overlay').classList.remove('active');
        }
        
        // Tab Switching
        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            if (tabName === 'full') {
                document.querySelectorAll('.tab')[0].classList.add('active');
                document.getElementById('fullNotesTab').classList.add('active');
            } else {
                document.querySelectorAll('.tab')[1].classList.add('active');
                document.getElementById('lastMinTab').classList.add('active');
            }
            
            window.scrollTo({top: 0, behavior: 'smooth'});
        }
        
        // Build TOC
        const chapters = [
            { title: 'Algorithm & Performance', id: 'ch1' },
            { title: 'Recurrence Relations', id: 'ch2' },
            { title: 'Data Structures Review', id: 'ch3' },
            { title: 'Sorting Algorithms', id: 'ch4' }
        ];
        
        const tocList = document.getElementById('tocList');
        chapters.forEach((ch, index) => {
            const li = document.createElement('li');
            li.innerHTML = `<span style="color: var(--primary); font-weight: 700;">${index + 1}.</span> ${ch.title}`;
            li.onclick = () => {
                const element = document.getElementById(ch.id);
                if (element) {
                    element.scrollIntoView({ behavior: 'smooth' });
                }
                closeTOC();
            };
            tocList.appendChild(li);
        });
    </script>
</body>
</html>