<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DSA Unit 2 - Linked Lists, Trees & Hashing</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 40px 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            padding: 50px;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            line-height: 1.8;
        }
        
        .header {
            text-align: center;
            margin-bottom: 40px;
            border-bottom: 3px solid #667eea;
            padding-bottom: 20px;
        }
        
        .header h1 {
            color: #333;
            font-size: 32px;
            margin-bottom: 5px;
        }
        
        .header p {
            color: #666;
            font-size: 14px;
        }
        
        .credit-line {
            font-size: 11px;
            color: #999;
            margin-top: 10px;
        }
        
        .section {
            margin-bottom: 35px;
            page-break-inside: avoid;
        }
        
        .chapter-title {
            font-size: 16px;
            font-weight: 700;
            color: #fff;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 12px 15px;
            margin-bottom: 20px;
            border-radius: 6px;
        }
        
        .section-title {
            font-size: 14px;
            font-weight: 700;
            color: #667eea;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-left: 4px solid #667eea;
            padding-left: 12px;
        }
        
        .subsection-title {
            font-size: 12px;
            font-weight: 700;
            color: #555;
            margin-top: 12px;
            margin-bottom: 8px;
        }
        
        .content {
            font-size: 12px;
            color: #444;
            line-height: 1.7;
        }
        
        .content p {
            margin-bottom: 8px;
        }
        
        .structure-box {
            background: #f0f4ff;
            border-left: 3px solid #667eea;
            padding: 12px;
            margin: 12px 0;
            border-radius: 4px;
            font-size: 11px;
            font-family: 'Courier New', monospace;
        }
        
        .point {
            margin-left: 15px;
            margin-bottom: 6px;
            font-size: 12px;
        }
        
        .advantage-box {
            background: #e8f5e9;
            border-left: 3px solid #4caf50;
            padding: 12px;
            margin: 12px 0;
            border-radius: 4px;
            font-size: 11px;
        }
        
        .disadvantage-box {
            background: #ffebee;
            border-left: 3px solid #f44336;
            padding: 12px;
            margin: 12px 0;
            border-radius: 4px;
            font-size: 11px;
        }
        
        .example-box {
            background: #fff3e0;
            border-left: 3px solid #ff9800;
            padding: 12px;
            margin: 12px 0;
            border-radius: 4px;
            font-size: 11px;
        }
        
        .important-box {
            background: #fce4ec;
            border-left: 3px solid #e91e63;
            padding: 12px;
            margin: 12px 0;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
        }
        
        .step-box {
            background: #f5f5f5;
            padding: 10px 12px;
            margin: 8px 0;
            border-radius: 4px;
            font-size: 11px;
            border-left: 3px solid #9c27b0;
        }
        
        .note-highlight {
            background: #ffeaa7;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            font-size: 11px;
            border-left: 3px solid #fdcb6e;
        }
        
        .one-liner {
            background: #e8f5e9;
            padding: 10px;
            margin: 8px 0;
            border-radius: 4px;
            font-size: 11px;
            border-left: 3px solid #4caf50;
            font-weight: 500;
        }
        
        .complexity-table {
            width: 100%;
            border-collapse: collapse;
            margin: 12px 0;
            font-size: 11px;
        }
        
        .complexity-table th, .complexity-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        
        .complexity-table th {
            background: #667eea;
            color: white;
            font-weight: 600;
        }
        
        .complexity-table tr:nth-child(even) {
            background: #f9f9f9;
        }
        
        .divider {
            height: 1px;
            background: #ddd;
            margin: 25px 0;
        }
        
        @media print {
            body {
                background: white;
                padding: 0;
            }
            
            .container {
                box-shadow: none;
                padding: 30px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìö DSA Unit 2 - Premium Master Notes</h1>
            <p>Linked Lists ‚Ä¢ Trees ‚Ä¢ Hashing</p>
            <p class="credit-line">Compiled & Formatted by Ankush Raj</p>
        </div>

        <!-- CHAPTER 2.1 -->
        <div class="chapter-title">‚≠ê CHAPTER 2.1 ‚Äî LINKED LISTS</div>

        <!-- Section 1 -->
        <div class="section">
            <div class="section-title">üåü 1. What is a Linked List? (Clear Explanation)</div>
            <div class="content">
                <p>A Linked List is a dynamic data structure used to store a collection of elements. Unlike arrays, a linked list does not store elements in continuous memory locations.</p>
                
                <p>Instead, it is made of several small parts called nodes.</p>
                
                <div class="note-highlight">
                    <strong>üî∏ Each node contains:</strong><br>
                    ‚Ä¢ Data ‚Äì the actual value<br>
                    ‚Ä¢ Pointer (Reference) ‚Äì the address of the next node
                </div>
                
                <p>So nodes are connected through pointers, forming a chain.</p>
                
                <div class="example-box">
                    <strong>Example (Imagine a chain):</strong><br>
                    [10 | next] ‚Üí [20 | next] ‚Üí [30 | next] ‚Üí NULL
                </div>
                
                <div class="subsection-title">‚≠ê Why do we use Linked Lists?</div>
                <div class="advantage-box">
                    ‚úî The size can grow or shrink at runtime<br>
                    ‚úî No memory is wasted<br>
                    ‚úî Insertion and deletion are fast (no shifting like arrays)
                </div>
                
                <div class="subsection-title">‚≠ê Limitations</div>
                <div class="disadvantage-box">
                    ‚úò Searching is slow ‚Üí O(n)<br>
                    ‚úò Extra memory for pointers<br>
                    ‚úò Cannot access elements directly by index
                </div>
            </div>
        </div>

        <!-- Section 2 -->
        <div class="section">
            <div class="section-title">üåü 2. Types of Linked Lists</div>
            <div class="content">
                <div class="subsection-title">üîπ 1) Singly Linked List (SLL)</div>
                <p>Each node has one pointer which points to the next node.</p>
                <div class="structure-box">
                    [data | next] ‚Üí [data | next] ‚Üí NULL
                </div>
                <p><strong>Features:</strong></p>
                <div class="point">
                    ‚Ä¢ Can move forward only
                </div>
                <div class="point">
                    ‚Ä¢ Simple and memory-efficient
                </div>
                
                <div class="subsection-title">üîπ 2) Doubly Linked List (DLL)</div>
                <p>Each node has two pointers: one for the next node and one for the previous node.</p>
                <div class="structure-box">
                    NULL ‚Üê [prev | data | next] ‚Üí [prev | data | next] ‚Üí NULL
                </div>
                <p><strong>Features:</strong></p>
                <div class="point">
                    ‚Ä¢ Can move both forward and backward
                </div>
                <div class="point">
                    ‚Ä¢ Faster deletion but uses more memory
                </div>
                
                <div class="subsection-title">üîπ 3) Circular Linked List (CLL)</div>
                <p>The last node points back to the first node.</p>
                <div class="structure-box">
                    A ‚Üí B ‚Üí C ‚Üí A (again)
                </div>
                <p><strong>Uses:</strong></p>
                <div class="point">
                    ‚Ä¢ Round-robin scheduling
                </div>
                <div class="point">
                    ‚Ä¢ Repeated processes
                </div>
            </div>
        </div>

        <!-- Section 3 -->
        <div class="section">
            <div class="section-title">üåü 3. Operations on Linked List</div>
            <div class="content">
                <div class="subsection-title">üîµ Insertion</div>
                
                <p><strong>1. Insert at Beginning</strong></p>
                <div class="step-box">
                    New node ‚Üí next = head<br>
                    head = new node<br>
                    <strong>Time: O(1)</strong>
                </div>
                
                <p><strong>2. Insert at End</strong></p>
                <div class="step-box">
                    Traverse to last node<br>
                    last.next = new node<br>
                    <strong>Time: O(n)</strong>
                </div>
                
                <p><strong>3. Insert After a Given Node</strong></p>
                <div class="step-box">
                    new.next = target.next<br>
                    target.next = new<br>
                    <strong>Time: O(1) (after finding target)</strong>
                </div>
                
                <div class="subsection-title">üîµ Deletion</div>
                
                <p><strong>1. Delete First Node</strong></p>
                <div class="step-box">
                    head = head.next<br>
                    <strong>Time: O(1)</strong>
                </div>
                
                <p><strong>2. Delete Last Node</strong></p>
                <div class="step-box">
                    Traverse to second-last node ‚Üí next = NULL<br>
                    <strong>Time: O(n)</strong>
                </div>
                
                <p><strong>3. Delete a Specific Value</strong></p>
                <div class="step-box">
                    Search + re-link pointers<br>
                    <strong>Time: O(n)</strong>
                </div>
                
                <div class="subsection-title">üîµ Searching</div>
                <p>Visit nodes one-by-one until the element is found. Time: O(n)</p>
            </div>
        </div>

        <!-- Section 4 -->
        <div class="section">
            <div class="section-title">üåü 4. Stack using Linked List</div>
            <div class="content">
                <p>A stack follows LIFO (Last In First Out). The head of the linked list works as the top of the stack.</p>
                
                <p><strong>Operations:</strong></p>
                <div class="point">
                    ‚Ä¢ push() ‚Üí insert at head
                </div>
                <div class="point">
                    ‚Ä¢ pop() ‚Üí delete head
                </div>
                <div class="point">
                    ‚Ä¢ peek() ‚Üí return head element
                </div>
                
                <p><strong>All operations: O(1)</strong></p>
            </div>
        </div>

        <!-- Section 5 -->
        <div class="section">
            <div class="section-title">üåü 5. Queue using Linked List</div>
            <div class="content">
                <p>A queue follows FIFO (First In First Out). Use two pointers:</p>
                
                <div class="point">
                    ‚Ä¢ front ‚Üí first node
                </div>
                <div class="point">
                    ‚Ä¢ rear ‚Üí last node
                </div>
                
                <p><strong>Operations:</strong></p>
                <div class="point">
                    ‚Ä¢ enqueue() ‚Üí insert at rear
                </div>
                <div class="point">
                    ‚Ä¢ dequeue() ‚Üí delete from front
                </div>
                
                <p><strong>All operations: O(1)</strong></p>
            </div>
        </div>

        <div class="divider"></div>

        <!-- CHAPTER 2.2 -->
        <div class="chapter-title">‚≠ê CHAPTER 2.2 ‚Äî TREES</div>

        <!-- Section 1 -->
        <div class="section">
            <div class="section-title">üåü 1. What is a Tree?</div>
            <div class="content">
                <p>A tree is a non-linear, hierarchical data structure consisting of nodes connected by edges.</p>
                
                <p><strong>Basic terms:</strong></p>
                <div class="point">
                    ‚Ä¢ Root ‚Äì topmost node
                </div>
                <div class="point">
                    ‚Ä¢ Parent ‚Äì node above another
                </div>
                <div class="point">
                    ‚Ä¢ Child ‚Äì node below another
                </div>
                <div class="point">
                    ‚Ä¢ Leaf ‚Äì no children
                </div>
                <div class="point">
                    ‚Ä¢ Height ‚Äì longest path from root to leaf
                </div>
                
                <p><strong>Trees are used to represent hierarchical structures like:</strong></p>
                <div class="advantage-box">
                    ‚úî file systems<br>
                    ‚úî organization charts<br>
                    ‚úî decision structures
                </div>
            </div>
        </div>

        <!-- Section 2 -->
        <div class="section">
            <div class="section-title">üåü 2. Binary Tree</div>
            <div class="content">
                <p>A Binary Tree is a tree in which each node has at most 2 children.</p>
                
                <p><strong>Types:</strong></p>
                <div class="point">
                    ‚Ä¢ Full Binary Tree ‚Äì each node has 0 or 2 children
                </div>
                <div class="point">
                    ‚Ä¢ Complete Binary Tree ‚Äì every level is filled left to right
                </div>
                <div class="point">
                    ‚Ä¢ Perfect Binary Tree ‚Äì all leaves at same level
                </div>
            </div>
        </div>

        <!-- Section 3 -->
        <div class="section">
            <div class="section-title">üåü 3. Binary Search Tree (BST)</div>
            <div class="content">
                <p>A BST is a binary tree that follows a sorted structure:</p>
                
                <div class="important-box">
                    Left child   <   Root   <   Right child
                </div>
                
                <p><strong>Operations:</strong></p>
                <div class="point">
                    ‚Ä¢ Search ‚Üí O(log n)
                </div>
                <div class="point">
                    ‚Ä¢ Insert ‚Üí O(log n)
                </div>
                <div class="point">
                    ‚Ä¢ Delete ‚Üí O(log n)
                </div>
                
                <div class="subsection-title">Deletion cases:</div>
                <div class="step-box">
                    1. Node with no child<br><br>
                    2. Node with one child<br><br>
                    3. Node with two children ‚Üí replace with inorder successor
                </div>
            </div>
        </div>

        <!-- Section 4 -->
        <div class="section">
            <div class="section-title">üåü 4. Tree Traversals</div>
            <div class="content">
                <div class="subsection-title">üîπ Depth-First Traversals</div>
                
                <p><strong>1) Inorder (Left ‚Üí Root ‚Üí Right)</strong></p>
                <div class="step-box">
                    Gives sorted output for BST
                </div>
                
                <p><strong>2) Preorder (Root ‚Üí Left ‚Üí Right)</strong></p>
                <div class="step-box">
                    Used for copying tree
                </div>
                
                <p><strong>3) Postorder (Left ‚Üí Right ‚Üí Root)</strong></p>
                <div class="step-box">
                    Used for deleting a tree
                </div>
                
                <div class="subsection-title">üîπ Breadth-First Traversal (Level-order)</div>
                <div class="point">
                    ‚Ä¢ Uses Queue
                </div>
                <div class="point">
                    ‚Ä¢ Visits level by level
                </div>
            </div>
        </div>

        <!-- Section 5 -->
        <div class="section">
            <div class="section-title">üåü 5. Balanced Search Trees</div>
            <div class="content">
                <p>A balanced tree maintains height close to log n, so operations remain efficient.</p>
                
                <p><strong>Examples:</strong></p>
                <div class="point">
                    ‚Ä¢ AVL Tree
                </div>
                <div class="point">
                    ‚Ä¢ Red-Black Tree
                </div>
                <div class="point">
                    ‚Ä¢ B-Tree
                </div>
            </div>
        </div>

        <!-- Section 6 -->
        <div class="section">
            <div class="section-title">üåü 6. Introduction to B-Tree</div>
            <div class="content">
                <p>A B-tree is a multi-way search tree used in databases and file systems.</p>
                
                <p><strong>Features:</strong></p>
                <div class="point">
                    ‚Ä¢ One node contains multiple keys
                </div>
                <div class="point">
                    ‚Ä¢ Children also multiple
                </div>
                <div class="point">
                    ‚Ä¢ Height remains low ‚Üí fast disk access
                </div>
            </div>
        </div>

        <!-- Section 7 -->
        <div class="section">
            <div class="section-title">üåü 7. Heap and Heap Sort</div>
            <div class="content">
                <div class="subsection-title">üîπ Heap</div>
                <p>A heap is a complete binary tree that satisfies:</p>
                <div class="point">
                    ‚Ä¢ Max-heap: parent ‚â• children
                </div>
                <div class="point">
                    ‚Ä¢ Min-heap: parent ‚â§ children
                </div>
                <p>Root contains the largest or smallest value.</p>
                
                <div class="subsection-title">üîπ Heap Sort Steps</div>
                <div class="step-box">
                    1. Build a max heap<br>
                    2. Swap root with last element<br>
                    3. Reduce heap size<br>
                    4. Heapify remaining<br>
                    5. Repeat
                </div>
                
                <div class="subsection-title">Time:</div>
                <div class="point">
                    ‚Ä¢ Build heap ‚Üí O(n)
                </div>
                <div class="point">
                    ‚Ä¢ Heap sort ‚Üí O(n log n)
                </div>
            </div>
        </div>

        <div class="divider"></div>

        <!-- CHAPTER 2.3 -->
        <div class="chapter-title">‚≠ê CHAPTER 2.3 ‚Äî HASHING</div>

        <!-- Section 1 -->
        <div class="section">
            <div class="section-title">üåü 1. What is Hashing?</div>
            <div class="content">
                <p>Hashing is a technique to store data using a hash function that converts a key ‚Üí index.</p>
                
                <div class="structure-box">
                    index = hash(key)
                </div>
                
                <p>This allows O(1) average search, insert, delete.</p>
                
                <p><strong>Used in:</strong></p>
                <div class="advantage-box">
                    ‚úî databases<br>
                    ‚úî hash tables<br>
                    ‚úî compiler symbol tables
                </div>
            </div>
        </div>

        <!-- Section 2 -->
        <div class="section">
            <div class="section-title">üåü 2. Collision</div>
            <div class="content">
                <p>A collision occurs when two keys get the same index.</p>
            </div>
        </div>

        <!-- Section 3 -->
        <div class="section">
            <div class="section-title">üåü 3. Collision Handling Methods</div>
            <div class="content">
                <div class="subsection-title">üîπ 1) Chaining</div>
                <div class="point">
                    ‚Ä¢ Each index stores a linked list
                </div>
                <div class="point">
                    ‚Ä¢ Simple and widely used
                </div>
                
                <div class="subsection-title">üîπ 2) Open Addressing</div>
                
                <p><strong>a) Linear Probing</strong></p>
                <div class="step-box">
                    Check next index: h(k) + i
                </div>
                
                <p><strong>b) Quadratic Probing</strong></p>
                <div class="step-box">
                    Use squares: h(k) + i¬≤
                </div>
                
                <p><strong>c) Double Hashing</strong></p>
                <div class="step-box">
                    Use second hash function: h1(k) + i*h2(k)<br>
                    <strong>Most efficient among probing methods.</strong>
                </div>
            </div>
        </div>

        <div class="divider"></div>

        <!-- FINAL ONE-LINERS -->
        <div class="section">
            <div class="chapter-title">‚≠ê FINAL EXAM ONE-LINERS</div>
            <div class="content">
                <div class="one-liner">
                    ‚úî <strong>SLL</strong> ‚Üí forward only
                </div>
                <div class="one-liner">
                    ‚úî <strong>DLL</strong> ‚Üí backward + forward
                </div>
                <div class="one-liner">
                    ‚úî <strong>Stack LL</strong> ‚Üí head operations
                </div>
                <div class="one-liner">
                    ‚úî <strong>Queue LL</strong> ‚Üí front-rear
                </div>
                <div class="one-liner">
                    ‚úî <strong>BST</strong> ‚Üí left < root < right
                </div>
                <div class="one-liner">
                    ‚úî <strong>Inorder</strong> ‚Üí sorted BST
                </div>
                <div class="one-liner">
                    ‚úî <strong>Heap</strong> ‚Üí complete binary tree
                </div>
                <div class="one-liner">
                    ‚úî <strong>Hashing</strong> ‚Üí O(1) average
                </div>
                <div class="one-liner">
                    ‚úî <strong>Chaining</strong> ‚Üí linked list inside table
                </div>
                <div class="one-liner">
                    ‚úî <strong>Double hashing</strong> ‚Üí two hash functions
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('keydown', function(e) {
            if ((e.ctrlKey || e.metaKey) && e.key === 'p') {
                window.print();
            }
        });
    </script>
</body>
</html>