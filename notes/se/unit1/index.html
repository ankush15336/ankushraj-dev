<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Software Engineering - Unit 1 | ankushraj.dev</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --primary: #3b82f6;
            --secondary: #8b5cf6;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --text: #333;
            --text-light: #6b7280;
            --bg: #f5f7fa;
            --card-bg: #ffffff;
            --border: #e5e7eb;
            --code-bg: #f3f4f6;
        }
        
        body.dark-mode {
            --text: #f0f0f0;
            --text-light: #9ca3af;
            --bg: #111827;
            --card-bg: #1f2937;
            --border: #374151;
            --code-bg: #374151;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
            transition: background 0.3s, color 0.3s;
        }
        
        /* Print Styles */
        @media print {
            @page {
                margin: 15mm 10mm 12mm 10mm;
                size: A4;
            }
            
            body {
                font-size: 13px;
                line-height: 1.45;
            }
            
            body::before {
                content: "ankushraj.dev";
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%) rotate(-45deg);
                font-size: 70px;
                font-weight: 200;
                color: rgba(0, 0, 0, 0.04);
                z-index: -1;
            }
            
            .header-controls, .tabs-container, .toc-panel, .overlay {
                display: none !important;
            }
        }
        
        /* Header */
        .header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
            padding: 12px 16px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .header-title {
            text-align: center;
        }
        
        .header-title h1 {
            font-size: 24px;
            font-weight: 800;
            margin-bottom: 4px;
        }
        
        .header-title p {
            font-size: 14px;
            opacity: 0.9;
        }
        
        .header-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 12px;
        }
        
        .btn {
            flex: 1;
            max-width: 150px;
            padding: 10px 16px;
            border: none;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.25);
            color: white;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }
        
        .btn:hover {
            background: rgba(255, 255, 255, 0.35);
            transform: translateY(-2px);
        }
        
        /* Tabs */
        .tabs-container {
            background: var(--card-bg);
            border-bottom: 2px solid var(--border);
            display: flex;
        }
        
        .tab {
            flex: 1;
            padding: 16px;
            text-align: center;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            color: var(--text-light);
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }
        
        .tab.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
            background: rgba(59, 130, 246, 0.05);
        }
        
        /* TOC Panel */
        .toc-panel {
            display: none;
            position: fixed;
            left: 0;
            top: 0;
            width: 85%;
            max-width: 320px;
            height: 100vh;
            background: var(--card-bg);
            z-index: 1000;
            overflow-y: auto;
            box-shadow: 4px 0 12px rgba(0,0,0,0.2);
            transform: translateX(-100%);
            transition: transform 0.3s ease;
        }
        
        .toc-panel.active {
            display: block;
            transform: translateX(0);
        }
        
        .toc-header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
            padding: 16px;
            font-size: 16px;
            font-weight: 700;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .toc-close {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            font-size: 18px;
            cursor: pointer;
        }
        
        .toc-list {
            list-style: none;
            padding: 0;
        }
        
        .toc-list li {
            padding: 14px 16px;
            font-size: 13px;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .toc-list li:hover {
            background: var(--bg);
            color: var(--primary);
            padding-left: 24px;
        }
        
        /* Overlay */
        .overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 999;
        }
        
        .overlay.active {
            display: block;
        }
        
        /* Container */
        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 12px;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
            animation: fadeIn 0.4s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .chapter-title {
            font-size: 18px;
            font-weight: 800;
            color: white;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            padding: 14px 16px;
            margin-bottom: 16px;
            margin-left: -12px;
            margin-right: -12px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .section {
            margin-bottom: 24px;
        }
        
        .section-title {
            font-size: 16px;
            font-weight: 700;
            color: var(--primary);
            margin-bottom: 10px;
            padding-bottom: 6px;
            border-bottom: 2px solid var(--primary);
        }
        
        .subsection-title {
            font-size: 14px;
            font-weight: 700;
            color: var(--text);
            margin-top: 12px;
            margin-bottom: 6px;
        }
        
        .content p {
            margin-bottom: 10px;
            font-size: 14px;
            line-height: 1.65;
        }
        
        /* Content Boxes */
        .definition-box, .code-box, .advantage-box, .threat-box, 
        .step-box, .example-box, .mindmap-box, .note-box {
            padding: 12px;
            border-radius: 8px;
            margin: 10px 0;
            font-size: 13px;
            line-height: 1.65;
        }
        
        .definition-box {
            background: rgba(59, 130, 246, 0.1);
            border-left: 4px solid var(--primary);
        }
        
        .code-box {
            background: var(--code-bg);
            border-left: 4px solid #6b7280;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
            white-space: pre-wrap;
        }
        
        .advantage-box {
            background: rgba(16, 185, 129, 0.1);
            border-left: 4px solid var(--success);
        }
        
        .threat-box {
            background: rgba(239, 68, 68, 0.1);
            border-left: 4px solid var(--danger);
        }
        
        .step-box {
            background: rgba(245, 158, 11, 0.1);
            border-left: 4px solid var(--warning);
        }
        
        .example-box {
            background: rgba(139, 92, 246, 0.1);
            border-left: 4px solid var(--secondary);
        }
        
        .mindmap-box {
            background: rgba(139, 92, 246, 0.05);
            border: 2px dashed var(--secondary);
            text-align: center;
            padding: 20px;
        }
        
        .note-box {
            background: rgba(245, 158, 11, 0.1);
            border-left: 4px solid var(--warning);
        }
        
        .point {
            margin-left: 18px;
            margin-bottom: 6px;
            font-size: 13px;
            position: relative;
        }
        
        .point::before {
            content: "‚Ä¢";
            position: absolute;
            left: -14px;
            color: var(--primary);
            font-weight: 700;
        }
        
        .divider {
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--border), transparent);
            margin: 24px 0;
        }
        
        /* Footer */
        .footer {
            text-align: center;
            padding: 16px;
            background: var(--card-bg);
            border-top: 2px solid var(--border);
            margin-top: 32px;
        }
        
        .footer-credit {
            font-size: 14px;
            color: var(--text);
            font-weight: 600;
        }
        
        .footer-credit strong {
            color: var(--primary);
        }
        
        .footer-note {
            font-size: 11px;
            color: var(--text-light);
            margin-top: 4px;
        }
        
        /* Responsive */
        @media (min-width: 768px) {
            .container { padding: 16px; }
            .header { padding: 14px 20px; }
            .header-title h1 { font-size: 28px; }
            .chapter-title { font-size: 20px; padding: 16px 20px; }
            .section-title { font-size: 18px; }
            .content p { font-size: 15px; }
        }
    </style>
  <script>
    window.va = window.va || function () { (window.vaq = window.vaq || []).push(arguments); };
  </script>
  <script defer src="/_vercel/insights/script.js"></script>
</head>
<body>
    <!-- TOC Panel -->
    <div class="toc-panel" id="tocPanel">
        <div class="toc-header">
            <span>üìö Chapters</span>
            <button class="toc-close" onclick="closeTOC()">√ó</button>
        </div>
        <ul class="toc-list" id="tocList"></ul>
    </div>
    
    <!-- Overlay -->
    <div class="overlay" id="overlay" onclick="closeTOC()"></div>
    
    <!-- Header -->
    <div class="header">
        <div class="header-title">
            <h1>Software Engineering</h1>
            <p>Unit 1 - Introduction & Requirements</p>
        </div>
        
        <div class="header-controls">
            <button class="btn" onclick="openTOC()">
                <span>üìë</span><span>Chapters</span>
            </button>
            <button class="btn" id="darkModeBtn" onclick="toggleDarkMode()">
                <span>üåô</span><span>Dark</span>
            </button>
            <button class="btn" onclick="window.print()">
                <span>üì•</span><span>PDF</span>
            </button>
        </div>
    </div>
    
    <!-- Tabs -->
    <div class="tabs-container">
        <div class="tab active" onclick="switchTab('full')">üìñ Full Notes</div>
        <div class="tab" onclick="switchTab('lastmin')">‚ö° Last Min Notes</div>
    </div>
    
    <!-- Content -->
    <div class="container">
        <!-- FULL NOTES TAB -->
        <div class="tab-content active" id="fullNotesTab">
            
            <!-- CHAPTER 1: INTRODUCTION -->
            <div class="chapter-title" id="ch1">
                <span>üéØ</span>
                <span>Chapter 1 ‚Äî Introduction to Software Engineering</span>
            </div>
            
            <!-- Mind Map -->
            <div class="section">
                <div class="mindmap-box">
                    <strong style="color: var(--secondary); font-size: 16px;">üìä SOFTWARE ENGINEERING - MIND MAP</strong>
                    <div style="margin-top: 15px; text-align: left; max-width: 700px; margin-left: auto; margin-right: auto;">
                        <div class="point">Software ‚Üí Collection of programs + documentation</div>
                        <div class="point">Software Engineering ‚Üí Systematic approach to develop quality software</div>
                        <div class="point">Need ‚Üí Handle complexity, quality, cost, time management</div>
                        <div class="point">Program vs Product ‚Üí Product = Tested + Documented + Maintainable</div>
                        <div class="point">SDLC ‚Üí Phases: Planning ‚Üí Analysis ‚Üí Design ‚Üí Implementation ‚Üí Testing ‚Üí Maintenance</div>
                        <div class="point">Models ‚Üí Waterfall, Iterative, Prototype, Spiral, Agile, V-Model</div>
                    </div>
                </div>
            </div>
            
            <!-- Section 1: What is Software -->
            <div class="section">
                <div class="section-title">1. What is Software?</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>Definition:</strong><br>
                        Software is a collection of computer programs, procedures, documentation, and data that performs specific tasks on a computer system.
                    </div>
                    
                    <div class="example-box">
                        <strong>Real-life Example:</strong><br>
                        Think of software like recipes in a cookbook:<br>
                        ‚Ä¢ <strong>Programs:</strong> Step-by-step cooking instructions<br>
                        ‚Ä¢ <strong>Documentation:</strong> Ingredient list, tips, photos<br>
                        ‚Ä¢ <strong>Data:</strong> Measurements, cooking times<br><br>
                        Just as recipes guide you to make food, software guides the computer to perform tasks!
                    </div>
                    
                    <div class="subsection-title">Components of Software:</div>
                    <div class="step-box">
                        <strong>1. Programs:</strong> Set of instructions (code) that tell computer what to do<br>
                        <strong>2. Documentation:</strong> User manuals, technical guides, help files<br>
                        <strong>3. Data:</strong> Information processed by programs<br>
                        <strong>4. Procedures:</strong> Rules and guidelines for using the software
                    </div>
                    
                    <div class="subsection-title">Types of Software:</div>
                    <div class="code-box"><strong>1. System Software:</strong>
Controls hardware and provides platform for applications
Examples: Windows, Linux, macOS, Android

<strong>2. Application Software:</strong>
Performs specific tasks for users
Examples: MS Office, Photoshop, Chrome, WhatsApp

<strong>3. Utility Software:</strong>
Maintains and protects system
Examples: Antivirus, File compressor, Disk cleaner</div>
                    
                    <div class="note-box">
                        <strong>Key Point:</strong> Software is intangible (cannot touch), unlike hardware (keyboard, monitor). But software controls hardware to perform tasks!
                    </div>
                </div>
            </div>
            
            <!-- Section 2: What is Software Engineering -->
            <div class="section">
                <div class="section-title">2. What is Software Engineering?</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>Definition:</strong><br>
                        Software Engineering is a systematic, disciplined, and quantifiable approach to the development, operation, and maintenance of software. It applies engineering principles to software development.
                    </div>
                    
                    <p><strong>In Simple Words:</strong> Software Engineering is the process of designing, creating, testing, and maintaining software using structured methods and best practices.</p>
                    
                    <div class="example-box">
                        <strong>Analogy - Building a House:</strong><br>
                        <strong>Without Engineering:</strong> Just start building randomly<br>
                        ‚Üí Walls might collapse, no proper rooms, wasted materials<br><br>
                        
                        <strong>With Engineering:</strong> Follow systematic approach<br>
                        ‚Üí Plan blueprint ‚Üí Check foundation ‚Üí Build systematically ‚Üí Test strength<br>
                        ‚Üí Result: Strong, safe, well-designed house<br><br>
                        
                        <strong>Similarly in Software:</strong><br>
                        Without SE: Buggy, unmaintainable, poor quality code<br>
                        With SE: Reliable, maintainable, high-quality software
                    </div>
                    
                    <div class="subsection-title">Goals of Software Engineering:</div>
                    <div class="advantage-box">
                        ‚úì <strong>Quality:</strong> Develop defect-free, reliable software<br>
                        ‚úì <strong>Cost-Effective:</strong> Minimize development and maintenance cost<br>
                        ‚úì <strong>Time Management:</strong> Deliver on schedule<br>
                        ‚úì <strong>Maintainability:</strong> Easy to update and fix<br>
                        ‚úì <strong>Scalability:</strong> Handle growing user base<br>
                        ‚úì <strong>User Satisfaction:</strong> Meet user needs and expectations
                    </div>
                </div>
            </div>
            
            <!-- Section 3: Need of Software Engineering -->
            <div class="section">
                <div class="section-title">3. Need of Software Engineering</div>
                <div class="content">
                    <div class="step-box">
                        <strong>Why do we need Software Engineering?</strong><br>
                        As software systems became larger and more complex, traditional programming methods failed. Software Engineering was needed to solve these problems:
                    </div>
                    
                    <div class="subsection-title">1. Handle Complexity:</div>
                    <div class="example-box">
                        <strong>Problem:</strong> Modern software has millions of lines of code<br>
                        <strong>Example:</strong> Windows 10 has ~50 million lines of code<br>
                        <strong>Solution:</strong> SE provides methods to break complex systems into manageable modules
                    </div>
                    
                    <div class="subsection-title">2. Ensure Quality:</div>
                    <div class="example-box">
                        <strong>Problem:</strong> Buggy software causes crashes, data loss, security issues<br>
                        <strong>Example:</strong> A banking app bug could lose customer money<br>
                        <strong>Solution:</strong> SE uses testing, quality assurance, and standards
                    </div>
                    
                    <div class="subsection-title">3. Cost Management:</div>
                    <div class="example-box">
                        <strong>Problem:</strong> Poor planning leads to budget overruns<br>
                        <strong>Fact:</strong> 64% of software projects exceed budget<br>
                        <strong>Solution:</strong> SE provides cost estimation and resource planning
                    </div>
                    
                    <div class="subsection-title">4. Time Management:</div>
                    <div class="example-box">
                        <strong>Problem:</strong> Projects miss deadlines, delayed releases<br>
                        <strong>Example:</strong> Game delays cost millions in lost revenue<br>
                        <strong>Solution:</strong> SE uses project management and scheduling techniques
                    </div>
                    
                    <div class="subsection-title">5. Team Collaboration:</div>
                    <div class="example-box">
                        <strong>Problem:</strong> Large projects need multiple developers working together<br>
                        <strong>Challenge:</strong> Code conflicts, miscommunication<br>
                        <strong>Solution:</strong> SE provides version control, documentation, and team processes
                    </div>
                    
                    <div class="subsection-title">6. Maintenance:</div>
                    <div class="example-box">
                        <strong>Problem:</strong> 60-70% of software cost is maintenance<br>
                        <strong>Challenge:</strong> Understanding old code, adding features, fixing bugs<br>
                        <strong>Solution:</strong> SE emphasizes documentation and clean code practices
                    </div>
                    
                    <div class="note-box">
                        <strong>The Software Crisis (1960s-1970s):</strong><br>
                        Projects failed massively: Late delivery, over budget, low quality, didn't meet requirements.<br>
                        This led to the birth of Software Engineering as a discipline in 1968.
                    </div>
                </div>
            </div>
            
            <!-- Section 4: Program vs Product -->
            <div class="section">
                <div class="section-title">4. Difference Between Program and Product</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>Program:</strong> A set of instructions written to solve a specific problem.<br>
                        <strong>Product:</strong> A well-tested, documented, and complete software solution ready for end users.
                    </div>
                    
                    <div class="code-box"><strong>Comparison Table:</strong>

Aspect          | Program                | Product
--------------- | ---------------------- | ----------------------
Purpose         | Solve specific problem | Meet user needs
User            | Developer/Small group  | General public
Documentation   | Minimal or none        | Complete & detailed
Testing         | Basic/Informal         | Rigorous & systematic
Maintenance     | Not considered         | Long-term support
Quality         | May have bugs          | High quality expected
Cost            | Low                    | High
Lifespan        | Short-term             | Long-term
Example         | College assignment     | Microsoft Word</div>
                    
                    <div class="example-box">
                        <strong>Example - Calculator:</strong><br><br>
                        
                        <strong>Program (Calculator in Python):</strong><br>
                        ‚Ä¢ Written in 30 minutes<br>
                        ‚Ä¢ Does basic addition/subtraction<br>
                        ‚Ä¢ Works on developer's computer<br>
                        ‚Ä¢ No error handling<br>
                        ‚Ä¢ No documentation<br>
                        ‚Ä¢ Just the code file<br><br>
                        
                        <strong>Product (Windows Calculator):</strong><br>
                        ‚Ä¢ Developed over months by team<br>
                        ‚Ä¢ Multiple operations, scientific mode, history<br>
                        ‚Ä¢ Works on all Windows versions<br>
                        ‚Ä¢ Handles all errors gracefully<br>
                        ‚Ä¢ Complete user manual, help section<br>
                        ‚Ä¢ Installer, updates, support<br>
                        ‚Ä¢ Tested on thousands of scenarios
                    </div>
                    
                    <div class="note-box">
                        <strong>Key Takeaway:</strong> A program becomes a product when it's:<br>
                        ‚úì Thoroughly tested<br>
                        ‚úì Well documented<br>
                        ‚úì User-friendly<br>
                        ‚úì Maintainable<br>
                        ‚úì Reliable and robust
                    </div>
                </div>
            </div>
            
            <!-- Section 5: SDLC Basics -->
            <div class="section">
                <div class="section-title">5. Software Development Life Cycle (SDLC)</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>What is SDLC?</strong><br>
                        Software Development Life Cycle (SDLC) is a systematic process used by software industry to design, develop, test, and deploy high-quality software. It defines phases/stages through which software passes from conception to retirement.
                    </div>
                    
                    <div class="example-box">
                        <strong>Real-life Analogy - Building a Car:</strong><br>
                        1. Planning: What type of car? Features? Budget?<br>
                        2. Design: Create blueprints, interior/exterior design<br>
                        3. Manufacturing: Build the car in factory<br>
                        4. Testing: Safety tests, performance tests<br>
                        5. Launch: Deliver to showrooms<br>
                        6. Maintenance: Service centers, spare parts<br><br>
                        Similarly, software goes through systematic phases!
                    </div>
                    
                    <div class="subsection-title">SDLC Phases:</div>
                    
                    <div class="step-box">
                        <strong>Phase 1: Planning (Feasibility Study)</strong><br>
                        ‚Ä¢ Define project scope<br>
                        ‚Ä¢ Identify stakeholders<br>
                        ‚Ä¢ Estimate cost, time, resources<br>
                        ‚Ä¢ Check if project is feasible (technical, economic, operational)<br>
                        <strong>Output:</strong> Project plan, feasibility report
                    </div>
                    
                    <div class="step-box">
                        <strong>Phase 2: Requirement Analysis</strong><br>
                        ‚Ä¢ Gather user requirements<br>
                        ‚Ä¢ Understand what software should do<br>
                        ‚Ä¢ Document functional and non-functional requirements<br>
                        ‚Ä¢ Create Software Requirement Specification (SRS)<br>
                        <strong>Output:</strong> SRS document
                    </div>
                    
                    <div class="step-box">
                        <strong>Phase 3: Design</strong><br>
                        ‚Ä¢ Create system architecture<br>
                        ‚Ä¢ Design database schema<br>
                        ‚Ä¢ Design user interface (UI/UX)<br>
                        ‚Ä¢ Plan modules and their interactions<br>
                        <strong>Output:</strong> Design documents, diagrams
                    </div>
                    
                    <div class="step-box">
                        <strong>Phase 4: Implementation (Coding)</strong><br>
                        ‚Ä¢ Write actual code<br>
                        ‚Ä¢ Follow coding standards<br>
                        ‚Ä¢ Develop modules<br>
                        ‚Ä¢ Integrate modules<br>
                        <strong>Output:</strong> Source code
                    </div>
                    
                    <div class="step-box">
                        <strong>Phase 5: Testing</strong><br>
                        ‚Ä¢ Find and fix bugs<br>
                        ‚Ä¢ Unit testing, integration testing, system testing<br>
                        ‚Ä¢ Verify software meets requirements<br>
                        ‚Ä¢ Performance and security testing<br>
                        <strong>Output:</strong> Test reports, bug-free software
                    </div>
                    
                    <div class="step-box">
                        <strong>Phase 6: Deployment</strong><br>
                        ‚Ä¢ Install software in production environment<br>
                        ‚Ä¢ User training<br>
                        ‚Ä¢ Data migration (if needed)<br>
                        ‚Ä¢ Go live!<br>
                        <strong>Output:</strong> Working software for users
                    </div>
                    
                    <div class="step-box">
                        <strong>Phase 7: Maintenance</strong><br>
                        ‚Ä¢ Fix bugs reported by users<br>
                        ‚Ä¢ Add new features<br>
                        ‚Ä¢ Adapt to new environments<br>
                        ‚Ä¢ Performance optimization<br>
                        <strong>Output:</strong> Updated software versions
                    </div>
                    
                    <div class="note-box">
                        <strong>Important:</strong> Maintenance is the longest and most expensive phase, often lasting years!
                    </div>
                </div>
            </div>
            
            <div class="divider"></div>
            
            <!-- Section 6: SDLC Models -->
            <div class="section">
                <div class="section-title">6. SDLC Models (Life Cycle Models)</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>What are SDLC Models?</strong><br>
                        SDLC Models are frameworks that define the process, activities, and tasks involved in software development. Different models suit different types of projects.
                    </div>
                    
                    <p><strong>Why Different Models?</strong> Different projects have different requirements - some need quick delivery, others need high reliability. Each model offers a different approach to organize the development process.</p>
                </div>
            </div>
            
            <!-- Waterfall Model -->
            <div class="section">
                <div class="section-title">7. Waterfall Model</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>Waterfall Model:</strong><br>
                        The Waterfall Model is a sequential software development approach where each phase must be completed before the next phase begins. Like a waterfall, progress flows downward through phases.
                    </div>
                    
                    <div class="code-box"><strong>Waterfall Model Phases:</strong>

Phase 1: Requirements Analysis
         ‚Üì
Phase 2: System Design
         ‚Üì
Phase 3: Implementation (Coding)
         ‚Üì
Phase 4: Testing
         ‚Üì
Phase 5: Deployment
         ‚Üì
Phase 6: Maintenance

<strong>Key Feature:</strong> NO going back to previous phase!</div>
                    
                    <div class="example-box">
                        <strong>Real-life Example - Assembly Line:</strong><br>
                        Think of a car assembly line:<br>
                        1. Design the car ‚Üí 2. Build chassis ‚Üí 3. Install engine ‚Üí 4. Paint ‚Üí 5. Quality check<br>
                        Each step happens in order. You can't paint before installing the engine!<br><br>
                        Similarly, in Waterfall, you complete requirements before design, design before coding, etc.
                    </div>
                    
                    <div class="step-box">
                        <strong>Detailed Phases:</strong><br><br>
                        <strong>1. Requirement Gathering & Analysis:</strong><br>
                        ‚Ä¢ Collect all requirements from client<br>
                        ‚Ä¢ Document everything in SRS<br>
                        ‚Ä¢ No changes allowed after this phase<br><br>
                        
                        <strong>2. System Design:</strong><br>
                        ‚Ä¢ Create architecture design<br>
                        ‚Ä¢ Database design, UI design<br>
                        ‚Ä¢ Module design<br><br>
                        
                        <strong>3. Implementation:</strong><br>
                        ‚Ä¢ Write code based on design<br>
                        ‚Ä¢ Develop all modules<br><br>
                        
                        <strong>4. Testing:</strong><br>
                        ‚Ä¢ Test entire system<br>
                        ‚Ä¢ Fix bugs<br><br>
                        
                        <strong>5. Deployment:</strong><br>
                        ‚Ä¢ Release to production<br>
                        ‚Ä¢ Install at client site<br><br>
                        
                        <strong>6. Maintenance:</strong><br>
                        ‚Ä¢ Fix issues, updates
                    </div>
                    
                    <div class="advantage-box">
                        <strong>Advantages:</strong><br>
                        ‚úì Simple and easy to understand<br>
                        ‚úì Well-defined phases with clear milestones<br>
                        ‚úì Easy to manage (each phase has deliverables)<br>
                        ‚úì Works well for small projects with clear requirements<br>
                        ‚úì Good documentation at each phase
                    </div>
                    
                    <div class="threat-box">
                        <strong>Disadvantages:</strong><br>
                        ‚úó No flexibility - cannot go back to previous phase<br>
                        ‚úó Difficult to accommodate changing requirements<br>
                        ‚úó Working software available only at the end<br>
                        ‚úó High risk if requirements are not clear initially<br>
                        ‚úó Not suitable for large, complex projects<br>
                        ‚úó Customer sees product only after completion
                    </div>
                    
                    <div class="note-box">
                        <strong>When to Use Waterfall Model:</strong><br>
                        ‚Ä¢ Requirements are clear and fixed<br>
                        ‚Ä¢ Small projects<br>
                        ‚Ä¢ Technology is well understood<br>
                        ‚Ä¢ Example: Payroll system for small company
                    </div>
                </div>
            </div>
            
            <!-- Iterative Waterfall Model -->
            <div class="section">
                <div class="section-title">8. Iterative Waterfall Model</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>Iterative Waterfall Model:</strong><br>
                        An improved version of Waterfall that allows feedback and revision. You can go back to the previous phase if needed.
                    </div>
                    
                    <div class="code-box"><strong>Iterative Waterfall Flow:</strong>

Requirements ‚Üê‚îÄ‚îê
     ‚Üì         ‚îÇ
Design    ‚Üê‚îÄ‚îê  ‚îÇ
     ‚Üì      ‚îÇ  ‚îÇ
Implementation ‚Üê‚îÄ‚î§
     ‚Üì         ‚îÇ
Testing       ‚îÇ
     ‚Üì         ‚îÇ
Deployment ‚îÄ‚îÄ‚îÄ‚îò
     ‚Üì
Maintenance

<strong>Key Difference:</strong> Feedback arrows allow going back!</div>
                    
                    <div class="example-box">
                        <strong>Example:</strong><br>
                        During testing phase, if a design flaw is found, you can go back to design phase, fix it, then continue. This was not possible in classic Waterfall.
                    </div>
                    
                    <div class="advantage-box">
                        <strong>Advantages:</strong><br>
                        ‚úì Feedback and corrections possible<br>
                        ‚úì Errors caught early can be fixed<br>
                        ‚úì More flexible than Waterfall<br>
                        ‚úì Reduces risk
                    </div>
                    
                    <div class="threat-box">
                        <strong>Disadvantages:</strong><br>
                        ‚úó Still sequential in nature<br>
                        ‚úó Can become costly if many iterations<br>
                        ‚úó Working software still comes late
                    </div>
                </div>
            </div>
            
            <!-- Prototype Model -->
            <div class="section">
                <div class="section-title">9. Prototype Model</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>Prototype Model:</strong><br>
                        A working model (prototype) of the software is built early to understand requirements better. Based on user feedback, the actual software is developed.
                    </div>
                    
                    <div class="code-box"><strong>Prototype Model Steps:</strong>

Step 1: Gather initial requirements
         ‚Üì
Step 2: Build quick prototype
         ‚Üì
Step 3: User evaluates prototype
         ‚Üì
Step 4: Refine requirements
         ‚Üì
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ  Satisfied? ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    NO   ‚îÇ   ‚îÇ YES
    ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚Üì
         Develop actual software
         ‚Üì
         Test & Deploy</div>
                    
                    <div class="example-box">
                        <strong>Real-life Example - House Model:</strong><br>
                        Before building a house, architect shows you a miniature model:<br>
                        ‚Ä¢ You see the layout, design<br>
                        ‚Ä¢ Give feedback: "I want bigger windows"<br>
                        ‚Ä¢ Architect updates the model<br>
                        ‚Ä¢ Once approved, actual construction begins<br><br>
                        Similarly, prototype gives users early preview of software!
                    </div>
                    
                    <div class="subsection-title">Types of Prototyping:</div>
                    <div class="step-box">
                        <strong>1. Throwaway/Rapid Prototype:</strong><br>
                        ‚Ä¢ Quick, rough prototype<br>
                        ‚Ä¢ Used only to understand requirements<br>
                        ‚Ä¢ Discarded after feedback<br>
                        ‚Ä¢ Actual software built from scratch<br><br>
                        
                        <strong>2. Evolutionary Prototype:</strong><br>
                        ‚Ä¢ Initial prototype is continuously refined<br>
                        ‚Ä¢ Each version adds more features<br>
                        ‚Ä¢ Final prototype becomes actual software
                    </div>
                    
                    <div class="advantage-box">
                        <strong>Advantages:</strong><br>
                        ‚úì User involvement from early stage<br>
                        ‚úì Better understanding of requirements<br>
                        ‚úì Reduces risk of building wrong product<br>
                        ‚úì Missing functionality identified early<br>
                        ‚úì Users get early feel of the system
                    </div>
                    
                    <div class="threat-box">
                        <strong>Disadvantages:</strong><br>
                        ‚úó Time-consuming to build prototypes<br>
                        ‚úó Users may think prototype is final product<br>
                        ‚úó Can lead to scope creep (endless changes)<br>
                        ‚úó May require skilled developers
                    </div>
                    
                    <div class="note-box">
                        <strong>When to Use Prototype Model:</strong><br>
                        ‚Ä¢ Requirements are unclear or changing<br>
                        ‚Ä¢ New technology being used<br>
                        ‚Ä¢ User interface is complex<br>
                        ‚Ä¢ Example: New web application with unique UI
                    </div>
                </div>
            </div>
            
            <!-- Evolutionary Model -->
            <div class="section">
                <div class="section-title">10. Evolutionary Model</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>Evolutionary Model:</strong><br>
                        Software is developed in increments (versions). Initial version has core features, then new features are added in subsequent versions based on user feedback.
                    </div>
                    
                    <div class="code-box"><strong>Evolutionary Development:</strong>

Version 1.0: Core features only
     ‚Üì
User Feedback
     ‚Üì
Version 1.5: Core + Some new features
     ‚Üì
User Feedback
     ‚Üì
Version 2.0: More features added
     ‚Üì
... continues evolving

<strong>Example:</strong>
WhatsApp:
v1.0 ‚Üí Just messaging
v2.0 ‚Üí Voice calls added
v3.0 ‚Üí Video calls added
v4.0 ‚Üí Status feature added</div>
                    
                    <div class="example-box">
                        <strong>Real-life Example - Video Game Updates:</strong><br>
                        ‚Ä¢ Initial release: Basic game with main story<br>
                        ‚Ä¢ Update 1: New characters, weapons<br>
                        ‚Ä¢ Update 2: Multiplayer mode<br>
                        ‚Ä¢ Update 3: New maps, challenges<br><br>
                        Game keeps evolving based on player feedback!
                    </div>
                    
                    <div class="advantage-box">
                        <strong>Advantages:</strong><br>
                        ‚úì Users get working software quickly<br>
                        ‚úì Adapts to changing requirements<br>
                        ‚úì Continuous user feedback improves quality<br>
                        ‚úì Risk is spread across versions<br>
                        ‚úì Core functionality delivered early
                    </div>
                    
                    <div class="threat-box">
                        <strong>Disadvantages:</strong><br>
                        ‚úó May lack proper documentation<br>
                        ‚úó Architecture may become messy over time<br>
                        ‚úó Difficult to plan long-term<br>
                        ‚úó May require more management effort
                    </div>
                </div>
            </div>
            
            <!-- Spiral Model -->
            <div class="section">
                <div class="section-title">11. Spiral Model</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>Spiral Model:</strong><br>
                        Combines iterative development with systematic aspects of Waterfall. It focuses heavily on risk analysis. The project passes through the same phases repeatedly in spirals.
                    </div>
                    
                    <div class="code-box"><strong>Spiral Model - Four Quadrants:</strong>

Each Spiral has 4 phases:

Quadrant 1: Planning (Objective Setting)
‚Ä¢ Identify objectives
‚Ä¢ Alternative solutions
‚Ä¢ Constraints

Quadrant 2: Risk Analysis
‚Ä¢ Identify risks
‚Ä¢ Evaluate alternatives
‚Ä¢ Resolve risks (may build prototype)

Quadrant 3: Engineering (Development & Testing)
‚Ä¢ Develop product
‚Ä¢ Testing

Quadrant 4: Evaluation (Customer Review)
‚Ä¢ Customer evaluates
‚Ä¢ Plan next iteration

Then next spiral begins...</div>
                    
                    <div class="example-box">
                        <strong>Visual Representation:</strong><br>
                        Imagine a spiral staircase:<br>
                        ‚Ä¢ You keep going in circles, but each circle is at a higher level<br>
                        ‚Ä¢ Each circle = one complete iteration<br>
                        ‚Ä¢ With each iteration, the software becomes more complete<br>
                        ‚Ä¢ Risk analysis happens at every level
                    </div>
                    
                    <div class="example-box">
                        <strong>Real-world Example - NASA Software:</strong><br>
                        When developing spacecraft software:<br>
                        ‚Ä¢ <strong>Spiral 1:</strong> Basic flight system (high risk - analyze thoroughly)<br>
                        ‚Ä¢ <strong>Spiral 2:</strong> Add navigation (risks identified and mitigated)<br>
                        ‚Ä¢ <strong>Spiral 3:</strong> Add communication (lower risk now)<br>
                        ‚Ä¢ <strong>Spiral 4:</strong> Add life support systems<br><br>
                        Risk analysis at each stage ensures safety!
                    </div>
                    
                    <div class="advantage-box">
                        <strong>Advantages:</strong><br>
                        ‚úì High emphasis on risk analysis<br>
                        ‚úì Good for large, complex, high-risk projects<br>
                        ‚úì Flexible - can accommodate changes<br>
                        ‚úì Customer feedback at each spiral<br>
                        ‚úì Working software produced early<br>
                        ‚úì Risks identified and resolved early
                    </div>
                    
                    <div class="threat-box">
                        <strong>Disadvantages:</strong><br>
                        ‚úó Complex and expensive<br>
                        ‚úó Requires expertise in risk analysis<br>
                        ‚úó Not suitable for small projects<br>
                        ‚úó Time-consuming<br>
                        ‚úó Success depends on risk analysis phase
                    </div>
                    
                    <div class="note-box">
                        <strong>When to Use Spiral Model:</strong><br>
                        ‚Ä¢ Large, expensive, complex projects<br>
                        ‚Ä¢ High-risk projects<br>
                        ‚Ä¢ Requirements are complex and unclear<br>
                        ‚Ä¢ Example: Military software, Aerospace systems, Banking systems
                    </div>
                </div>
            </div>
            
            <!-- Agile Model -->
            <div class="section">
                <div class="section-title">12. Agile Model</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>Agile Model:</strong><br>
                        Agile is an iterative and incremental approach that emphasizes flexibility, customer collaboration, and rapid delivery of working software. Development happens in short cycles called "Sprints" (typically 2-4 weeks).
                    </div>
                    
                    <div class="code-box"><strong>Agile Development Cycle:</strong>

Sprint (2-4 weeks):
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 1. Plan features        ‚îÇ
‚îÇ 2. Design               ‚îÇ
‚îÇ 3. Develop              ‚îÇ
‚îÇ 4. Test                 ‚îÇ
‚îÇ 5. Review & Demo        ‚îÇ
‚îÇ 6. Get Feedback         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚Üì
    Next Sprint
         ‚Üì
Working software delivered every sprint!

<strong>Popular Agile Frameworks:</strong>
‚Ä¢ Scrum
‚Ä¢ Kanban
‚Ä¢ Extreme Programming (XP)</div>
                    
                    <div class="example-box">
                        <strong>Real-life Example - Restaurant Kitchen:</strong><br>
                        Traditional (Waterfall): Take all orders, cook everything, serve everything at once<br>
                        ‚Üí Customers wait long, food gets cold<br><br>
                        
                        Agile (Modern Kitchen): <br>
                        ‚Ä¢ Take one order ‚Üí Cook ‚Üí Serve immediately<br>
                        ‚Ä¢ Take next order ‚Üí Cook ‚Üí Serve<br>
                        ‚Ä¢ Get feedback instantly ‚Üí Adjust next dish<br>
                        ‚Üí Customers get hot food quickly, can give immediate feedback!
                    </div>
                    
                    <div class="subsection-title">Agile Principles:</div>
                    <div class="step-box">
                        1. <strong>Customer satisfaction:</strong> Deliver working software frequently<br>
                        2. <strong>Welcome changes:</strong> Even late in development<br>
                        3. <strong>Deliver frequently:</strong> Every 2-4 weeks<br>
                        4. <strong>Collaboration:</strong> Business people and developers work daily<br>
                        5. <strong>Trust:</strong> Build projects around motivated individuals<br>
                        6. <strong>Face-to-face:</strong> Best communication is in person<br>
                        7. <strong>Working software:</strong> Primary measure of progress<br>
                        8. <strong>Sustainable pace:</strong> Maintain constant development speed<br>
                        9. <strong>Technical excellence:</strong> Focus on good design<br>
                        10. <strong>Simplicity:</strong> Maximize work not done<br>
                        11. <strong>Self-organizing teams:</strong> Teams make decisions<br>
                        12. <strong>Regular reflection:</strong> Team reflects and adjusts
                    </div>
                    
                    <div class="advantage-box">
                        <strong>Advantages:</strong><br>
                        ‚úì Quick delivery of working software<br>
                        ‚úì Highly flexible to changes<br>
                        ‚úì Customer involved throughout<br>
                        ‚úì Minimal documentation (more focus on code)<br>
                        ‚úì Face-to-face communication<br>
                        ‚úì Suitable for uncertain requirements<br>
                        ‚úì Continuous testing and improvement
                    </div>
                    
                    <div class="threat-box">
                        <strong>Disadvantages:</strong><br>
                        ‚úó Less predictability (hard to estimate cost/time)<br>
                        ‚úó Requires experienced team<br>
                        ‚úó Lack of documentation can be problematic<br>
                        ‚úó Needs active customer involvement<br>
                        ‚úó Not suitable for fixed-price contracts<br>
                        ‚úó Can be chaotic without discipline
                    </div>
                    
                    <div class="note-box">
                        <strong>When to Use Agile:</strong><br>
                        ‚Ä¢ Requirements change frequently<br>
                        ‚Ä¢ Need quick market release<br>
                        ‚Ä¢ Customer available for collaboration<br>
                        ‚Ä¢ Example: Mobile apps, Web applications, Startups
                    </div>
                </div>
            </div>
            
            <!-- V-Model -->
            <div class="section">
                <div class="section-title">13. V-Model (Verification & Validation)</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>V-Model:</strong><br>
                        V-Model is an extension of Waterfall where testing activities are planned parallel to development activities. It's called V-Model because of its V-shaped diagram showing the relationship between development and testing phases.
                    </div>
                    
                    <div class="code-box"><strong>V-Model Diagram:</strong>

VERIFICATION (Left Side)     VALIDATION (Right Side)

Requirements ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí Acceptance Testing
     ‚Üì                                ‚Üë
System Design ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí System Testing
     ‚Üì                                ‚Üë
Architecture Design ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí Integration Testing
     ‚Üì                                ‚Üë
Module Design ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí Unit Testing
     ‚Üì                                ‚Üë
       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
       ‚îÇ IMPLEMENTATION  ‚îÇ
       ‚îÇ    (Coding)     ‚îÇ
       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

<strong>Key Point:</strong> Each development phase has corresponding test phase!</div>
                    
                    <div class="example-box">
                        <strong>How V-Model Works:</strong><br><br>
                        
                        <strong>Left Side (Verification - "Are we building it right?"):</strong><br>
                        ‚Ä¢ Requirements ‚Üí Plan Acceptance Testing<br>
                        ‚Ä¢ System Design ‚Üí Plan System Testing<br>
                        ‚Ä¢ Architecture ‚Üí Plan Integration Testing<br>
                        ‚Ä¢ Module Design ‚Üí Plan Unit Testing<br><br>
                        
                        <strong>Bottom:</strong><br>
                        ‚Ä¢ Actual Coding happens<br><br>
                        
                        <strong>Right Side (Validation - "Are we building the right thing?"):</strong><br>
                        ‚Ä¢ Unit Testing ‚Üí Test individual modules<br>
                        ‚Ä¢ Integration Testing ‚Üí Test module interactions<br>
                        ‚Ä¢ System Testing ‚Üí Test entire system<br>
                        ‚Ä¢ Acceptance Testing ‚Üí User acceptance
                    </div>
                    
                    <div class="advantage-box">
                        <strong>Advantages:</strong><br>
                        ‚úì Testing is planned from the beginning<br>
                        ‚úì Defects found early<br>
                        ‚úì Clear and well-defined phases<br>
                        ‚úì Works well for small to medium projects<br>
                        ‚úì Higher success rate than Waterfall<br>
                        ‚úì Good for systems requiring high reliability
                    </div>
                    
                    <div class="threat-box">
                        <strong>Disadvantages:</strong><br>
                        ‚úó Rigid like Waterfall (not flexible)<br>
                        ‚úó Cannot handle changing requirements<br>
                        ‚úó No early prototypes<br>
                        ‚úó Not suitable for complex projects<br>
                        ‚úó Software available only after complete development
                    </div>
                    
                    <div class="note-box">
                        <strong>When to Use V-Model:</strong><br>
                        ‚Ä¢ Requirements are clear and fixed<br>
                        ‚Ä¢ Project is small to medium size<br>
                        ‚Ä¢ Need high reliability (medical, embedded systems)<br>
                        ‚Ä¢ Example: Medical devices, Automotive software
                    </div>
                </div>
            </div>
            
            <!-- Comparison -->
            <div class="section">
                <div class="section-title">14. SDLC Models Comparison</div>
                <div class="content">
                    <div class="code-box"><strong>Quick Comparison Table:</strong>

Model         | Flexibility | Risk    | Cost    | Best For
------------- | ----------- | ------- | ------- | --------
Waterfall     | Low         | High    | Low     | Small, clear requirements
Iterative     | Medium      | Medium  | Medium  | Medium projects
Prototype     | High        | Low     | High    | Unclear requirements
Evolutionary  | High        | Low     | High    | Evolving features
Spiral        | High        | Low     | High    | Large, risky projects
Agile         | Very High   | Low     | Medium  | Changing requirements
V-Model       | Low         | Medium  | Medium  | High reliability needed</div>
                </div>
            </div>
            
            <div class="divider"></div>
            
            <!-- CHAPTER 2: SOFTWARE REQUIREMENTS -->
            <div class="chapter-title" id="ch2">
                <span>üìã</span>
                <span>Chapter 2 ‚Äî Software Requirements</span>
            </div>
            
            <!-- Section 1: Requirement Analysis -->
            <div class="section">
                <div class="section-title">1. Requirement Analysis</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>What is Requirement Analysis?</strong><br>
                        Requirement Analysis is the process of gathering, analyzing, documenting, and validating the needs and expectations of stakeholders for a software system. It answers "WHAT the system should do" (not HOW).
                    </div>
                    
                    <div class="example-box">
                        <strong>Real-life Example - Building a House:</strong><br>
                        Before construction:<br>
                        ‚Ä¢ How many rooms? ‚Üí 3 bedrooms, 2 bathrooms<br>
                        ‚Ä¢ What facilities? ‚Üí Kitchen, garage, garden<br>
                        ‚Ä¢ What style? ‚Üí Modern, minimalist<br>
                        ‚Ä¢ Budget? ‚Üí ‚Çπ50 lakh<br><br>
                        These are REQUIREMENTS! Same way, software needs clear requirements before development.
                    </div>
                    
                    <div class="subsection-title">Types of Requirements:</div>
                    
                    <div class="step-box">
                        <strong>1. Functional Requirements:</strong><br>
                        What the system MUST DO<br><br>
                        <strong>Example - Online Shopping App:</strong><br>
                        ‚Ä¢ User can browse products<br>
                        ‚Ä¢ User can add items to cart<br>
                        ‚Ä¢ User can make payment<br>
                        ‚Ä¢ System sends order confirmation email<br>
                        ‚Ä¢ Admin can add/remove products
                    </div>
                    
                    <div class="step-box">
                        <strong>2. Non-Functional Requirements:</strong><br>
                        HOW WELL the system performs<br><br>
                        <strong>Example - Online Shopping App:</strong><br>
                        ‚Ä¢ Performance: Page loads in < 2 seconds<br>
                        ‚Ä¢ Security: User data encrypted<br>
                        ‚Ä¢ Availability: System up 99.9% time<br>
                        ‚Ä¢ Usability: Easy to navigate<br>
                        ‚Ä¢ Scalability: Handle 10,000 concurrent users
                    </div>
                    
                    <div class="subsection-title">Steps in Requirement Analysis:</div>
                    <div class="code-box"><strong>Step-by-Step Process:</strong>

Step 1: Requirement Elicitation (Gathering)
‚Ä¢ Interview stakeholders
‚Ä¢ Conduct surveys
‚Ä¢ Observe current system
‚Ä¢ Study documents
‚Ä¢ Brainstorming sessions

Step 2: Requirement Analysis
‚Ä¢ Identify conflicts
‚Ä¢ Prioritize requirements (Must-have, Nice-to-have)
‚Ä¢ Check feasibility
‚Ä¢ Remove ambiguities

Step 3: Requirement Documentation
‚Ä¢ Write in SRS document
‚Ä¢ Create diagrams (Use Cases, Data Flow)
‚Ä¢ Get stakeholder approval

Step 4: Requirement Validation
‚Ä¢ Review with stakeholders
‚Ä¢ Check completeness
‚Ä¢ Check consistency
‚Ä¢ Check realism</div>
                    
                    <div class="note-box">
                        <strong>Important:</strong> 60-70% of software failures are due to poor requirements! Getting requirements right is crucial.
                    </div>
                </div>
            </div>
            
            <!-- Section 2: Analysis Principles -->
            <div class="section">
                <div class="section-title">2. Analysis Principles</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>Analysis Principles:</strong><br>
                        These are fundamental guidelines that should be followed during requirement analysis to ensure quality and completeness.
                    </div>
                    
                    <div class="step-box">
                        <strong>1. Information Domain Principle:</strong><br>
                        Understand the data that flows in and out of the system<br>
                        ‚Ä¢ Input data<br>
                        ‚Ä¢ Output data<br>
                        ‚Ä¢ Data stored<br>
                        ‚Ä¢ Data processed
                    </div>
                    
                    <div class="step-box">
                        <strong>2. Functional Principle:</strong><br>
                        Define what functions the system performs<br>
                        ‚Ä¢ Break system into functions<br>
                        ‚Ä¢ Each function should have single purpose<br>
                        ‚Ä¢ Functions should be independent
                    </div>
                    
                    <div class="step-box">
                        <strong>3. Behavioral Principle:</strong><br>
                        Understand how system behaves in different scenarios<br>
                        ‚Ä¢ Normal behavior<br>
                        ‚Ä¢ Error conditions<br>
                        ‚Ä¢ State changes
                    </div>
                    
                    <div class="step-box">
                        <strong>4. Partition Principle:</strong><br>
                        Divide complex system into smaller, manageable parts<br>
                        ‚Ä¢ Divide and conquer approach<br>
                        ‚Ä¢ Each part easier to understand<br>
                        ‚Ä¢ Reduces complexity
                    </div>
                    
                    <div class="step-box">
                        <strong>5. Essential and Implementation Views:</strong><br>
                        ‚Ä¢ <strong>Essential View:</strong> WHAT system does (requirements)<br>
                        ‚Ä¢ <strong>Implementation View:</strong> HOW system does it (design)<br>
                        During analysis, focus on WHAT, not HOW!
                    </div>
                    
                    <div class="example-box">
                        <strong>Example - ATM System:</strong><br>
                        <strong>Information Domain:</strong> Card number, PIN, account balance<br>
                        <strong>Functional:</strong> Withdraw cash, check balance, deposit<br>
                        <strong>Behavioral:</strong> What happens if wrong PIN? If insufficient balance?<br>
                        <strong>Partition:</strong> Authentication module, Transaction module, Display module
                    </div>
                </div>
            </div>
            
            <!-- Section 3: Software Prototyping -->
            <div class="section">
                <div class="section-title">3. Software Prototyping</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>Software Prototyping:</strong><br>
                        Building a working model of software to help understand and refine requirements. It's a "quick and dirty" version to get user feedback early.
                    </div>
                    
                    <div class="subsection-title">Purpose of Prototyping:</div>
                    <div class="advantage-box">
                        ‚úì Validate requirements early<br>
                        ‚úì Clarify unclear requirements<br>
                        ‚úì Get user feedback before full development<br>
                        ‚úì Reduce risk of building wrong product<br>
                        ‚úì Improve communication with users<br>
                        ‚úì Test technical feasibility
                    </div>
                    
                    <div class="subsection-title">Prototyping Tools:</div>
                    <div class="example-box">
                        <strong>Common Tools:</strong><br>
                        ‚Ä¢ Figma, Adobe XD (UI/UX prototypes)<br>
                        ‚Ä¢ Balsamiq (Wireframes)<br>
                        ‚Ä¢ InVision (Interactive prototypes)<br>
                        ‚Ä¢ PowerPoint (Quick mockups)<br>
                        ‚Ä¢ HTML/CSS (Web prototypes)
                    </div>
                    
                    <div class="note-box">
                        <strong>Remember:</strong> Prototype ‚â† Final Product. It's just for understanding requirements, not production-ready code!
                    </div>
                </div>
            </div>
            
            <!-- Section 4: Specification -->
            <div class="section">
                <div class="section-title">4. Specification</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>Specification:</strong><br>
                        A detailed description of the software system to be developed. It precisely defines what the system should do, its constraints, and quality attributes.
                    </div>
                    
                    <div class="subsection-title">Why Specification is Important:</div>
                    <div class="step-box">
                        ‚Ä¢ <strong>For Developers:</strong> Blueprint to build the system<br>
                        ‚Ä¢ <strong>For Testers:</strong> Basis for test cases<br>
                        ‚Ä¢ <strong>For Clients:</strong> Agreement on what will be delivered<br>
                        ‚Ä¢ <strong>For Management:</strong> Project planning and cost estimation<br>
                        ‚Ä¢ <strong>For Maintenance:</strong> Understanding system for future updates
                    </div>
                    
                    <div class="subsection-title">Characteristics of Good Specification:</div>
                    <div class="advantage-box">
                        ‚úì <strong>Complete:</strong> All requirements covered<br>
                        ‚úì <strong>Consistent:</strong> No contradictions<br>
                        ‚úì <strong>Unambiguous:</strong> Clear, single interpretation<br>
                        ‚úì <strong>Verifiable:</strong> Can be tested<br>
                        ‚úì <strong>Modifiable:</strong> Easy to update<br>
                        ‚úì <strong>Traceable:</strong> Each requirement can be tracked<br>
                        ‚úì <strong>Ranked:</strong> Prioritized (critical vs nice-to-have)
                    </div>
                </div>
            </div>
            
            <!-- Section 5: SRS -->
            <div class="section">
                <div class="section-title">5. Software Requirement Specification (SRS)</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>SRS Document:</strong><br>
                        Software Requirement Specification (SRS) is a comprehensive document that describes the complete behavior of the system to be developed. It's the foundation of the software project.
                    </div>
                    
                    <div class="example-box">
                        <strong>Think of SRS as:</strong><br>
                        A contract between client and developer. It clearly states:<br>
                        ‚Ä¢ What will be built<br>
                        ‚Ä¢ How it should behave<br>
                        ‚Ä¢ Performance expectations<br>
                        ‚Ä¢ Constraints and limitations
                    </div>
                    
                    <div class="subsection-title">Characteristics of Good SRS:</div>
                    <div class="code-box"><strong>1. Correct:</strong>
Every requirement accurately represents customer needs

<strong>2. Unambiguous:</strong>
Each requirement has only ONE interpretation
Bad: "System should be fast"
Good: "System response time < 2 seconds"

<strong>3. Complete:</strong>
All requirements are documented
Nothing is "obvious" or assumed

<strong>4. Consistent:</strong>
No conflicting requirements
Example of conflict: "System must be simple" AND "System must have advanced features"

<strong>5. Ranked (Prioritized):</strong>
Essential/Desirable/Optional
Must-have vs Nice-to-have

<strong>6. Verifiable:</strong>
Can be tested/measured
Bad: "System should be user-friendly"
Good: "User can complete checkout in 3 clicks"

<strong>7. Modifiable:</strong>
Easy to update when requirements change
Proper structure and indexing

<strong>8. Traceable:</strong>
Each requirement has unique ID
Can trace from requirement ‚Üí design ‚Üí code ‚Üí test</div>
                    
                    <div class="subsection-title">Components of SRS:</div>
                    <div class="step-box">
                        <strong>1. Introduction:</strong><br>
                        ‚Ä¢ Purpose of document<br>
                        ‚Ä¢ Scope of software<br>
                        ‚Ä¢ Definitions, acronyms, abbreviations<br>
                        ‚Ä¢ References<br>
                        ‚Ä¢ Overview of document<br><br>
                        
                        <strong>2. Overall Description:</strong><br>
                        ‚Ä¢ Product perspective (how it fits with other systems)<br>
                        ‚Ä¢ Product functions (high-level)<br>
                        ‚Ä¢ User characteristics<br>
                        ‚Ä¢ Constraints (technical, regulatory)<br>
                        ‚Ä¢ Assumptions and dependencies<br><br>
                        
                        <strong>3. Specific Requirements:</strong><br>
                        ‚Ä¢ Functional requirements (detailed)<br>
                        ‚Ä¢ External interface requirements (UI, hardware, software, communication)<br>
                        ‚Ä¢ Performance requirements<br>
                        ‚Ä¢ Database requirements<br>
                        ‚Ä¢ Design constraints<br>
                        ‚Ä¢ Quality attributes (reliability, security, maintainability)<br><br>
                        
                        <strong>4. Appendices:</strong><br>
                        ‚Ä¢ Diagrams (Use Case, Data Flow, ER diagrams)<br>
                        ‚Ä¢ Sample inputs/outputs<br>
                        ‚Ä¢ Data dictionary<br>
                        ‚Ä¢ Index
                    </div>
                    
                    <div class="note-box">
                        <strong>IEEE Standard 830:</strong> International standard for writing SRS documents. Provides template and guidelines.
                    </div>
                </div>
            </div>
            
            <!-- Section 6: Data Modelling -->
            <div class="section">
                <div class="section-title">6. Data Modelling</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>Data Modelling:</strong><br>
                        Data modelling is the process of defining data structures, their relationships, and constraints. It shows what data the system stores and how different data elements relate to each other.
                    </div>
                    
                    <div class="example-box">
                        <strong>Real-life Example - Library System:</strong><br>
                        <strong>Entities (Data):</strong><br>
                        ‚Ä¢ Book (Title, Author, ISBN, Copies)<br>
                        ‚Ä¢ Member (Name, ID, Phone, Address)<br>
                        ‚Ä¢ Loan (Loan Date, Return Date, Fine)<br><br>
                        
                        <strong>Relationships:</strong><br>
                        ‚Ä¢ Member BORROWS Book<br>
                        ‚Ä¢ Book HAS Author<br>
                        ‚Ä¢ Loan RECORDS borrowing
                    </div>
                    
                    <div class="subsection-title">Entity-Relationship (ER) Model:</div>
                    <div class="definition-box">
                        <strong>ER Model:</strong> Most popular data modelling technique. Uses entities, attributes, and relationships.
                    </div>
                    
                    <div class="code-box"><strong>ER Model Components:</strong>

1. Entity: Real-world object
   Example: Student, Course, Employee
   Represented by: Rectangle

2. Attribute: Property of entity
   Example: Student has Name, Roll No, Age
   Represented by: Oval

3. Relationship: Association between entities
   Example: Student ENROLLS IN Course
   Represented by: Diamond

4. Cardinality: Number of instances
   ‚Ä¢ One-to-One (1:1)
   ‚Ä¢ One-to-Many (1:N)
   ‚Ä¢ Many-to-Many (M:N)</div>
                    
                    <div class="example-box">
                        <strong>Example - University System:</strong><br>
                        <strong>Entities:</strong><br>
                        ‚Ä¢ Student (StudentID, Name, Email, DOB)<br>
                        ‚Ä¢ Course (CourseID, CourseName, Credits)<br>
                        ‚Ä¢ Professor (ProfessorID, Name, Department)<br><br>
                        
                        <strong>Relationships:</strong><br>
                        ‚Ä¢ Student ENROLLS IN Course (Many-to-Many)<br>
                        ‚Ä¢ Professor TEACHES Course (One-to-Many)<br>
                        ‚Ä¢ Student HAS Advisor (Many-to-One)
                    </div>
                    
                    <div class="note-box">
                        <strong>Why Data Modelling?</strong><br>
                        ‚Ä¢ Understand data requirements clearly<br>
                        ‚Ä¢ Design database structure<br>
                        ‚Ä¢ Identify redundancy and inconsistency<br>
                        ‚Ä¢ Communication tool between stakeholders
                    </div>
                </div>
            </div>
            
            <!-- Section 7: Functional Modelling -->
            <div class="section">
                <div class="section-title">7. Functional Modelling and Information Flow</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>Functional Modelling:</strong><br>
                        Functional modelling describes WHAT the system does - the functions/processes and how data flows through them. It focuses on transforming inputs into outputs.
                    </div>
                    
                    <div class="subsection-title">Data Flow Diagram (DFD):</div>
                    <div class="definition-box">
                        <strong>DFD:</strong> Graphical representation showing how data flows through a system, what processes transform the data, and where data is stored.
                    </div>
                    
                    <div class="code-box"><strong>DFD Components:</strong>

1. Process (Function/Transformation)
   Symbol: Circle/Bubble
   Example: Calculate Total, Validate Login
   
2. Data Flow (Movement of data)
   Symbol: Arrow
   Example: User credentials ‚Üí

3. Data Store (Storage)
   Symbol: Two parallel lines
   Example: Database, File
   
4. External Entity (Source/Destination)
   Symbol: Rectangle
   Example: User, Admin, External System</div>
                    
                    <div class="subsection-title">DFD Levels:</div>
                    <div class="step-box">
                        <strong>Level 0 (Context Diagram):</strong><br>
                        ‚Ä¢ Highest level, most abstract<br>
                        ‚Ä¢ Shows system as single process<br>
                        ‚Ä¢ Shows external entities<br>
                        ‚Ä¢ Shows major data flows<br><br>
                        
                        <strong>Level 1 DFD:</strong><br>
                        ‚Ä¢ Breaks Level 0 into major processes<br>
                        ‚Ä¢ Shows main functions of system<br>
                        ‚Ä¢ More detailed than Context Diagram<br><br>
                        
                        <strong>Level 2 DFD:</strong><br>
                        ‚Ä¢ Further breaks down Level 1 processes<br>
                        ‚Ä¢ Very detailed<br>
                        ‚Ä¢ Shows sub-functions
                    </div>
                    
                    <div class="example-box">
                        <strong>Example - Online Shopping DFD (Level 0):</strong><br>
                        <code>
                        Customer ‚Üí [Online Shopping System] ‚Üí Order Details<br>
                        Customer ‚Üê [Online Shopping System] ‚Üê Product Info<br>
                        Admin ‚Üí [Online Shopping System] ‚Üí Inventory Update<br>
                        </code><br><br>
                        
                        <strong>Level 1 DFD:</strong><br>
                        <code>
                        Customer ‚Üí Browse Products ‚Üí Product Database<br>
                        Customer ‚Üí Add to Cart ‚Üí Cart Database<br>
                        Customer ‚Üí Checkout ‚Üí Order Database<br>
                        Customer ‚Üí Make Payment ‚Üí Payment Gateway<br>
                        Admin ‚Üí Manage Inventory ‚Üí Product Database<br>
                        </code>
                    </div>
                    
                    <div class="subsection-title">Information Flow:</div>
                    <div class="definition-box">
                        <strong>Information Flow:</strong> The path that information takes through a system from input to output.
                    </div>
                    
                    <div class="example-box">
                        <strong>Example - ATM Withdrawal:</strong><br>
                        1. Customer inserts card ‚Üí Card data flows to system<br>
                        2. Enter PIN ‚Üí PIN flows to validation process<br>
                        3. Validation process ‚Üí Checks against database<br>
                        4. Enter amount ‚Üí Amount flows to balance check process<br>
                        5. Balance check ‚Üí Queries account database<br>
                        6. Dispense cash ‚Üí Updates database<br>
                        7. Receipt ‚Üí Information flows to printer<br><br>
                        This shows complete information flow through ATM system!
                    </div>
                    
                    <div class="note-box">
                        <strong>Purpose of Functional Modelling:</strong><br>
                        ‚Ä¢ Understand system processes<br>
                        ‚Ä¢ Identify data transformations<br>
                        ‚Ä¢ Find data dependencies<br>
                        ‚Ä¢ Basis for system design<br>
                        ‚Ä¢ Communication with stakeholders
                    </div>
                </div>
            </div>
            
            <div class="divider"></div>
            
            <!-- Section 8: Behavioral Modelling -->
            <div class="section">
                <div class="section-title">8. Behavioral Modelling</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>Behavioral Modelling:</strong><br>
                        Behavioral modelling describes HOW the system behaves in response to events. It shows the dynamic behavior of the system - how it changes state over time and reacts to different inputs/events.
                    </div>
                    
                    <div class="example-box">
                        <strong>Real-life Example - Traffic Light:</strong><br>
                        <strong>States:</strong> Red, Yellow, Green<br>
                        <strong>Events:</strong> Timer expires<br>
                        <strong>Behavior:</strong><br>
                        ‚Ä¢ When Red and timer expires ‚Üí Change to Green<br>
                        ‚Ä¢ When Green and timer expires ‚Üí Change to Yellow<br>
                        ‚Ä¢ When Yellow and timer expires ‚Üí Change to Red<br><br>
                        This describes BEHAVIOR - how system changes state!
                    </div>
                    
                    <div class="subsection-title">State Transition Diagram (STD):</div>
                    <div class="definition-box">
                        <strong>State Transition Diagram:</strong> Visual representation showing different states of a system and transitions between them based on events/conditions.
                    </div>
                    
                    <div class="code-box"><strong>STD Components:</strong>

1. State: A condition or situation during object's life
   Symbol: Rounded rectangle
   Example: Logged In, Processing, Completed

2. Transition: Change from one state to another
   Symbol: Arrow
   Example: Submit button clicked ‚Üí

3. Event: Trigger that causes transition
   Example: Button click, Timer expires, Data received

4. Action: Activity performed during transition
   Example: Validate credentials, Send email

5. Initial State: Starting point
   Symbol: Filled circle

6. Final State: End point
   Symbol: Circle with inner filled circle</div>
                    
                    <div class="example-box">
                        <strong>Example - ATM Machine States:</strong><br>
                        <code>
                        [Start] ‚Üí Idle State<br>
                        ‚Üì (Card Inserted)<br>
                        Card Reading State<br>
                        ‚Üì (Card Valid)<br>
                        PIN Entry State<br>
                        ‚Üì (Correct PIN)<br>
                        Menu Display State<br>
                        ‚Üì (Select Withdrawal)<br>
                        Amount Entry State<br>
                        ‚Üì (Amount Valid & Sufficient Balance)<br>
                        Cash Dispensing State<br>
                        ‚Üì (Cash Dispensed)<br>
                        Receipt Printing State<br>
                        ‚Üì (Receipt Printed)<br>
                        [End] ‚Üí Return to Idle<br><br>
                        
                        <strong>Error States:</strong><br>
                        ‚Ä¢ Wrong PIN ‚Üí PIN Entry (max 3 attempts)<br>
                        ‚Ä¢ Insufficient Balance ‚Üí Menu Display<br>
                        ‚Ä¢ Card Invalid ‚Üí Eject Card ‚Üí Idle
                        </code>
                    </div>
                    
                    <div class="example-box">
                        <strong>Example - Online Order States:</strong><br>
                        1. <strong>Order Placed</strong> (Initial)<br>
                        2. Event: Payment Confirmed ‚Üí <strong>Order Confirmed</strong><br>
                        3. Event: Item Packed ‚Üí <strong>Ready to Ship</strong><br>
                        4. Event: Picked by Courier ‚Üí <strong>In Transit</strong><br>
                        5. Event: Reached Destination ‚Üí <strong>Out for Delivery</strong><br>
                        6. Event: Customer Received ‚Üí <strong>Delivered</strong> (Final)<br><br>
                        
                        <strong>Alternate Flows:</strong><br>
                        ‚Ä¢ From any state: Cancel Order ‚Üí <strong>Cancelled</strong><br>
                        ‚Ä¢ From Out for Delivery: Customer Not Home ‚Üí <strong>Return to Hub</strong>
                    </div>
                    
                    <div class="note-box">
                        <strong>When to Use Behavioral Modelling:</strong><br>
                        ‚Ä¢ System has multiple states<br>
                        ‚Ä¢ System behavior depends on history/sequence<br>
                        ‚Ä¢ Complex event-driven systems<br>
                        ‚Ä¢ Examples: Embedded systems, Protocol handlers, UI flows
                    </div>
                </div>
            </div>
            
            <!-- Section 9: Structural Modelling -->
            <div class="section">
                <div class="section-title">9. Mechanics of Structural Modelling</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>Structural Modelling:</strong><br>
                        Structural modelling focuses on the static structure of the system - what components exist, how they are organized, and how they relate to each other. It shows the "architecture" of the system.
                    </div>
                    
                    <div class="example-box">
                        <strong>Analogy - Building Blueprint:</strong><br>
                        Structural model is like architectural blueprint showing:<br>
                        ‚Ä¢ Rooms and their layout (Components)<br>
                        ‚Ä¢ How rooms connect (Relationships)<br>
                        ‚Ä¢ Walls, doors, windows (Structure)<br><br>
                        Similarly, software structural model shows components and their connections.
                    </div>
                    
                    <div class="subsection-title">Structure Chart:</div>
                    <div class="definition-box">
                        <strong>Structure Chart:</strong> Hierarchical diagram showing how system is broken down into modules and how modules interact.
                    </div>
                    
                    <div class="code-box"><strong>Structure Chart Components:</strong>

1. Module: A program unit that performs specific function
   Symbol: Rectangle with name
   Example: Validate User, Calculate Total

2. Module Call: One module calling another
   Symbol: Arrow pointing downward
   
3. Data Couple: Data passed between modules
   Symbol: Arrow with hollow circle
   Example: username, password
   
4. Control Couple: Control information passed
   Symbol: Arrow with filled circle
   Example: flag, status

5. Library Module: Reusable module
   Symbol: Rectangle with vertical lines on sides</div>
                    
                    <div class="example-box">
                        <strong>Example - Online Shopping Structure Chart:</strong><br>
                        <code>
                                Main System<br>
                                    |<br>
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê<br>
                    |           |           |<br>
                User Mgmt   Product Mgmt  Order Mgmt<br>
                    |           |           |<br>
            ‚îå‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îê<br>
            |   |   |   |   |   |   |   |   |<br>
          Login Reg Prof Browse Add Cart Checkout Pay Track<br>
                        </code><br>
                        Each box is a module, arrows show module calls.
                    </div>
                    
                    <div class="subsection-title">Principles of Good Structure:</div>
                    <div class="advantage-box">
                        <strong>1. Modularity:</strong> Break system into independent modules<br><br>
                        
                        <strong>2. Coupling (Should be Low):</strong><br>
                        Coupling = Degree of interdependence between modules<br>
                        ‚Ä¢ Low coupling = Good (modules are independent)<br>
                        ‚Ä¢ High coupling = Bad (changing one affects others)<br><br>
                        
                        <strong>3. Cohesion (Should be High):</strong><br>
                        Cohesion = Degree to which module's elements belong together<br>
                        ‚Ä¢ High cohesion = Good (module does one thing well)<br>
                        ‚Ä¢ Low cohesion = Bad (module does unrelated things)<br><br>
                        
                        <strong>Goal:</strong> High Cohesion + Low Coupling = Good Design
                    </div>
                    
                    <div class="example-box">
                        <strong>Example - Cohesion:</strong><br>
                        <strong>Low Cohesion (Bad):</strong><br>
                        Module "Utilities" that does:<br>
                        ‚Ä¢ Calculate discount<br>
                        ‚Ä¢ Send email<br>
                        ‚Ä¢ Validate phone number<br>
                        ‚Üí Unrelated functions!<br><br>
                        
                        <strong>High Cohesion (Good):</strong><br>
                        Module "EmailService" that only:<br>
                        ‚Ä¢ Send email<br>
                        ‚Ä¢ Format email<br>
                        ‚Ä¢ Validate email address<br>
                        ‚Üí All related to email!
                    </div>
                    
                    <div class="example-box">
                        <strong>Example - Coupling:</strong><br>
                        <strong>High Coupling (Bad):</strong><br>
                        Module A directly accesses Module B's internal data<br>
                        ‚Üí If B changes, A breaks!<br><br>
                        
                        <strong>Low Coupling (Good):</strong><br>
                        Module A calls Module B through well-defined interface<br>
                        ‚Üí B's internal changes don't affect A
                    </div>
                </div>
            </div>
            
            <!-- Section 10: Data Dictionary -->
            <div class="section">
                <div class="section-title">10. Data Dictionary</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>Data Dictionary:</strong><br>
                        A data dictionary is a centralized repository that contains definitions and descriptions of all data elements used in the system. It's like a "glossary" for data.
                    </div>
                    
                    <div class="example-box">
                        <strong>Think of it as:</strong><br>
                        A dictionary defines words ‚Üí "Apple: A round fruit, typically red or green"<br>
                        Data dictionary defines data ‚Üí "CustomerID: Unique 10-digit number identifying customer"
                    </div>
                    
                    <div class="subsection-title">Purpose of Data Dictionary:</div>
                    <div class="advantage-box">
                        ‚úì <strong>Consistency:</strong> Everyone uses same definitions<br>
                        ‚úì <strong>Communication:</strong> Clear understanding among team<br>
                        ‚úì <strong>Documentation:</strong> Reference for developers<br>
                        ‚úì <strong>Maintenance:</strong> Easy to update and track changes<br>
                        ‚úì <strong>Quality:</strong> Reduces ambiguity and errors
                    </div>
                    
                    <div class="subsection-title">Components of Data Dictionary Entry:</div>
                    <div class="code-box"><strong>For each data element, document:</strong>

1. Name: Unique identifier
   Example: CustomerID

2. Description: What it represents
   Example: Unique identifier for each customer

3. Data Type: Type of data
   Example: Integer, String, Date, Boolean

4. Size/Length: Maximum length
   Example: 10 digits, 50 characters

5. Format: Pattern/structure
   Example: XXX-XXX-XXXX for phone

6. Range: Valid values
   Example: Age between 18-100

7. Default Value: Initial value if not specified
   Example: Status = "Active"

8. Constraints: Rules/restrictions
   Example: NOT NULL, UNIQUE

9. Source: Where data comes from
   Example: User input, Database, API

10. Usage: Where/how it's used
    Example: Used in Login module, Order processing</div>
                    
                    <div class="example-box">
                        <strong>Example - Student Management System Data Dictionary:</strong><br><br>
                        
                        <strong>Data Element: StudentID</strong><br>
                        ‚Ä¢ Description: Unique identifier for student<br>
                        ‚Ä¢ Data Type: Integer<br>
                        ‚Ä¢ Length: 8 digits<br>
                        ‚Ä¢ Format: YYYYNNNN (Year + Sequential number)<br>
                        ‚Ä¢ Range: 20240001 to 20249999<br>
                        ‚Ä¢ Default: Auto-generated<br>
                        ‚Ä¢ Constraints: NOT NULL, PRIMARY KEY, UNIQUE<br>
                        ‚Ä¢ Source: System-generated on registration<br>
                        ‚Ä¢ Usage: Used in Enrollment, Grades, Attendance modules<br><br>
                        
                        <strong>Data Element: StudentName</strong><br>
                        ‚Ä¢ Description: Full name of student<br>
                        ‚Ä¢ Data Type: String<br>
                        ‚Ä¢ Length: 100 characters<br>
                        ‚Ä¢ Format: First Name + Last Name<br>
                        ‚Ä¢ Default: NULL<br>
                        ‚Ä¢ Constraints: NOT NULL, Alphabets only<br>
                        ‚Ä¢ Source: User input during registration<br>
                        ‚Ä¢ Usage: Display on ID card, reports, certificates<br><br>
                        
                        <strong>Data Element: DateOfBirth</strong><br>
                        ‚Ä¢ Description: Student's birth date<br>
                        ‚Ä¢ Data Type: Date<br>
                        ‚Ä¢ Format: DD-MM-YYYY<br>
                        ‚Ä¢ Range: 01-01-2000 to 01-01-2010<br>
                        ‚Ä¢ Constraints: NOT NULL, Must be 18+ years<br>
                        ‚Ä¢ Source: User input with verification<br>
                        ‚Ä¢ Usage: Age calculation, eligibility verification
                    </div>
                    
                    <div class="subsection-title">Data Dictionary Notation:</div>
                    <div class="code-box"><strong>Common Symbols Used:</strong>

= : is composed of
+ : and (concatenation)
[ ] : select one option
{ } : repetition (0 or more times)
( ) : optional
| : or (alternative)

<strong>Examples:</strong>

Address = Street + City + State + Zipcode

PhoneNumber = AreaCode + LocalNumber

Name = FirstName + [MiddleName] + LastName
       (MiddleName is optional)

Order = {OrderItem}
        (Order contains multiple OrderItems)

Payment = CreditCard | DebitCard | Cash
          (Select one payment method)</div>
                    
                    <div class="note-box">
                        <strong>Best Practices:</strong><br>
                        ‚Ä¢ Keep it up-to-date<br>
                        ‚Ä¢ Use consistent naming conventions<br>
                        ‚Ä¢ Include all data elements (even small ones)<br>
                        ‚Ä¢ Review regularly with team<br>
                        ‚Ä¢ Version control for tracking changes
                    </div>
                </div>
            </div>
            
            <!-- CHAPTER 3: Object Oriented Design - START -->
            <div class="chapter-title" id="ch3">
                <span>üé®</span>
                <span>Chapter 3 ‚Äî Function and Object Oriented Design</span>
            </div>
            
            <!-- Section 1: Structured Analysis -->
            <div class="section">
                <div class="section-title">1. Structured Analysis</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>Structured Analysis:</strong><br>
                        Structured analysis is a traditional approach that breaks down complex systems into smaller, manageable parts using functional decomposition. It focuses on processes/functions and data flows.
                    </div>
                    
                    <div class="subsection-title">Key Characteristics:</div>
                    <div class="step-box">
                        ‚Ä¢ <strong>Top-Down Approach:</strong> Start with high-level view, break down into details<br>
                        ‚Ä¢ <strong>Functional Decomposition:</strong> System divided based on functions<br>
                        ‚Ä¢ <strong>Process-Oriented:</strong> Focus on "what system does" (processes)<br>
                        ‚Ä¢ <strong>Tools Used:</strong> DFD, Structure Charts, Data Dictionary
                    </div>
                    
                    <div class="subsection-title">Structured vs Object-Oriented:</div>
                    <div class="code-box"><strong>Comparison:</strong>

Aspect          | Structured              | Object-Oriented
--------------- | ----------------------- | -----------------------
Focus           | Functions/Processes     | Objects/Entities
Approach        | Top-Down               | Bottom-Up
Decomposition   | Functional             | Object-based
Data & Function | Separate               | Combined (Encapsulation)
Reusability     | Limited                | High (Inheritance)
Maintenance     | Difficult              | Easier
Example Tool    | DFD, Structure Chart   | UML Diagrams
Best For        | Small systems          | Large, complex systems</div>
                    
                    <div class="example-box">
                        <strong>Example - Library System:</strong><br><br>
                        
                        <strong>Structured Approach:</strong><br>
                        Focus on functions:<br>
                        ‚Ä¢ IssueBook()<br>
                        ‚Ä¢ ReturnBook()<br>
                        ‚Ä¢ SearchBook()<br>
                        ‚Ä¢ AddMember()<br>
                        ‚Üí Functions are separate, data flows between them<br><br>
                        
                        <strong>Object-Oriented Approach:</strong><br>
                        Focus on objects:<br>
                        ‚Ä¢ Book (has properties: title, author; methods: display, update)<br>
                        ‚Ä¢ Member (has properties: name, ID; methods: borrow, return)<br>
                        ‚Ä¢ Library (manages books and members)<br>
                        ‚Üí Objects contain both data and functions together
                    </div>
                </div>
            </div>
            
            <!-- Section 2: Data Flow Diagrams (Detailed) -->
            <div class="section">
                <div class="section-title">2. Data Flow Diagrams (DFD) - Detailed</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>Data Flow Diagram (DFD):</strong><br>
                        A graphical representation showing how data moves through a system, what processes transform it, and where it's stored.
                    </div>
                    
                    <div class="subsection-title">DFD Rules:</div>
                    <div class="step-box">
                        <strong>1. Naming Conventions:</strong><br>
                        ‚Ä¢ Process: Verb + Noun (e.g., "Validate User", "Calculate Total")<br>
                        ‚Ä¢ Data Flow: Noun (e.g., "Order Details", "Customer Info")<br>
                        ‚Ä¢ Data Store: Plural noun (e.g., "Customers", "Orders")<br>
                        ‚Ä¢ External Entity: Noun (e.g., "Customer", "Admin")<br><br>
                        
                        <strong>2. Balancing:</strong><br>
                        ‚Ä¢ Inputs/outputs of parent process = Combined inputs/outputs of child processes<br>
                        ‚Ä¢ Maintain consistency across levels<br><br>
                        
                        <strong>3. Process Numbers:</strong><br>
                        ‚Ä¢ Level 0: Single process (entire system)<br>
                        ‚Ä¢ Level 1: 1.0, 2.0, 3.0...<br>
                        ‚Ä¢ Level 2: 1.1, 1.2, 1.3...<br><br>
                        
                        <strong>4. Common Mistakes to Avoid:</strong><br>
                        ‚Ä¢ No process between external entity and data store<br>
                        ‚Ä¢ Data store without input or output<br>
                        ‚Ä¢ Unlabeled data flows
                    </div>
                    
                    <div class="example-box">
                        <strong>Complete Example - Library Management System:</strong><br><br>
                        
                        <strong>Level 0 (Context Diagram):</strong><br>
                        <code>
                        Member ‚Üí [Library System] ‚Üí Book Details<br>
                        Member ‚Üê [Library System] ‚Üê Receipt<br>
                        Librarian ‚Üí [Library System] ‚Üí Book Updates<br>
                        </code><br><br>
                        
                        <strong>Level 1 DFD:</strong><br>
                        <code>
                        Member ‚Üí 1.0 Search Books ‚Üí Books DB<br>
                        Member ‚Üí 2.0 Issue Book ‚Üí Issue Records DB<br>
                        Member ‚Üí 3.0 Return Book ‚Üí Issue Records DB<br>
                        Librarian ‚Üí 4.0 Manage Books ‚Üí Books DB<br>
                        Librarian ‚Üí 5.0 Manage Members ‚Üí Members DB<br><br>
                        
                        Process Details:<br>
                        1.0: Search Books (Query ‚Üí Results)<br>
                        2.0: Issue Book (Member ID, Book ID ‚Üí Update Issue Records)<br>
                        3.0: Return Book (Issue ID ‚Üí Calculate Fine, Update Records)<br>
                        4.0: Manage Books (Add/Update/Delete Book Info)<br>
                        5.0: Manage Members (Add/Update Member Info)<br>
                        </code><br><br>
                        
                        <strong>Level 2 DFD (Expanding Process 2.0 - Issue Book):</strong><br>
                        <code>
                        2.1: Verify Member (Check if member exists & active)<br>
                        2.2: Check Book Availability (Check if book available)<br>
                        2.3: Create Issue Record (Generate issue ID, due date)<br>
                        2.4: Update Book Status (Mark as issued)<br>
                        2.5: Generate Receipt (Print receipt for member)<br>
                        </code>
                    </div>
                    
                    <div class="note-box">
                        <strong>Tips for Drawing Good DFDs:</strong><br>
                        ‚Ä¢ Start with Context Diagram (big picture)<br>
                        ‚Ä¢ Gradually decompose into more detailed levels<br>
                        ‚Ä¢ Keep it simple and readable<br>
                        ‚Ä¢ Validate with stakeholders<br>
                        ‚Ä¢ Use consistent naming
                    </div>
                </div>
            </div>
            
            <div class="divider"></div>
            
            <!-- Section 3: Basic Object Orientation Concepts -->
            <div class="section">
                <div class="section-title">3. Basic Object Orientation Concepts</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>Object-Oriented Approach:</strong><br>
                        Object-Oriented Programming (OOP) organizes software design around objects (real-world entities) rather than functions. Objects contain both data (attributes) and behavior (methods).
                    </div>
                    
                    <div class="example-box">
                        <strong>Real-world Example - Car:</strong><br>
                        <strong>Object:</strong> Your car<br>
                        <strong>Attributes:</strong> Color, Model, Speed<br>
                        <strong>Methods:</strong> start(), accelerate(), brake()<br><br>
                        The car is an object with properties and actions!
                    </div>
                    
                    <div class="subsection-title">Core OOP Concepts:</div>
                    
                    <div class="step-box">
                        <strong>1. Class & Object:</strong><br>
                        ‚Ä¢ <strong>Class:</strong> Blueprint/template<br>
                        ‚Ä¢ <strong>Object:</strong> Instance of class<br><br>
                        Example: Student (class) ‚Üí Raj, Priya (objects)
                    </div>
                    
                    <div class="step-box">
                        <strong>2. Encapsulation:</strong><br>
                        Bundling data and methods together, hiding internal details.<br><br>
                        Example: ATM - You withdraw money but don't see cash counting mechanism
                    </div>
                    
                    <div class="step-box">
                        <strong>3. Inheritance:</strong><br>
                        Child class acquires properties of parent class.<br><br>
                        Example: Vehicle (parent) ‚Üí Car, Bike (children inherit color, speed)
                    </div>
                    
                    <div class="step-box">
                        <strong>4. Polymorphism:</strong><br>
                        Same method, different behavior.<br><br>
                        Example: area() ‚Üí for square, rectangle, circle (different logic)
                    </div>
                    
                    <div class="step-box">
                        <strong>5. Abstraction:</strong><br>
                        Hiding complexity, showing only essentials.<br><br>
                        Example: Driving car - you use steering/pedals, don't know engine internals
                    </div>
                </div>
            </div>
            
            <!-- Section 4: UML -->
            <div class="section">
                <div class="section-title">4. Unified Modelling Language (UML)</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>UML:</strong> Standardized visual language for modeling software systems using diagrams.
                    </div>
                    
                    <div class="code-box"><strong>UML Diagram Types:</strong>

Structural (Static):
‚Ä¢ Class Diagram
‚Ä¢ Object Diagram
‚Ä¢ Component Diagram

Behavioral (Dynamic):
‚Ä¢ Use Case Diagram
‚Ä¢ Activity Diagram
‚Ä¢ State Diagram
‚Ä¢ Sequence Diagram</div>
                </div>
            </div>
            
            <!-- Section 5: Use Case -->
            <div class="section">
                <div class="section-title">5. Use Case Model & Diagram</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>Use Case:</strong> Describes how user (actor) interacts with system to achieve goal.
                    </div>
                    
                    <div class="code-box"><strong>Components:</strong>

‚Ä¢ Actor: Stick figure (User, Admin)
‚Ä¢ Use Case: Oval (Login, Place Order)
‚Ä¢ Include: <<include>> (mandatory)
‚Ä¢ Extend: <<extend>> (optional)

Example: Checkout <<include>> Login
         Checkout <<extend>> Apply Coupon</div>
                </div>
            </div>
            
            <!-- Section 6: Class Diagrams -->
            <div class="section">
                <div class="section-title">6. Class Diagrams</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>Class Diagram:</strong> Shows classes, attributes, methods, and relationships.
                    </div>
                    
                    <div class="code-box"><strong>Relationships:</strong>

Association: Student ‚îÄ‚îÄ‚îÄ Course
Aggregation: Department ‚óá‚îÄ‚îÄ‚îÄ Student (weak)
Composition: House ‚óÜ‚îÄ‚îÄ‚îÄ Room (strong)
Inheritance: Vehicle ‚ñ≥‚îÄ‚îÄ‚îÄ Car
Dependency: Order ---‚Üí Payment (uses)</div>
                </div>
            </div>
            
            <div class="divider"></div>
            
            <!-- Section 7: Interaction Diagrams -->
            <div class="section">
                <div class="section-title">7. Interaction Diagrams</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>Interaction Diagrams:</strong><br>
                        Show how objects interact with each other through messages. Focus on dynamic behavior - the flow of control and data between objects over time.
                    </div>
                    
                    <div class="subsection-title">Types of Interaction Diagrams:</div>
                    <div class="step-box">
                        <strong>1. Sequence Diagram:</strong> Shows time-ordered interactions<br>
                        <strong>2. Collaboration Diagram:</strong> Shows structural organization
                    </div>
                    
                    <div class="subsection-title">Sequence Diagram:</div>
                    <div class="definition-box">
                        <strong>Sequence Diagram:</strong> Shows interactions between objects in time sequence. Emphasizes the order in which messages are sent.
                    </div>
                    
                    <div class="code-box"><strong>Sequence Diagram Components:</strong>

‚Ä¢ Actor/Object: Box at top
‚Ä¢ Lifeline: Vertical dashed line
‚Ä¢ Activation: Thin rectangle on lifeline (object is active)
‚Ä¢ Message: Horizontal arrow between objects
‚Ä¢ Return: Dashed arrow (optional)
‚Ä¢ Self-call: Message to itself</div>
                    
                    <div class="example-box">
                        <strong>Example - ATM Withdrawal:</strong><br>
                        <code>
                        Customer    ATM        Bank      Account<br>
                        |           |          |         |<br>
                        |--insert card--->|   |         |<br>
                        |<--request PIN---|   |         |<br>
                        |--enter PIN----->|   |         |<br>
                        |           |--verify PIN-->|   |<br>
                        |           |<--PIN OK------|   |<br>
                        |--select amount->|   |         |<br>
                        |           |--check balance--->|<br>
                        |           |<--balance OK-----|<br>
                        |           |--debit amount--->|<br>
                        |<--dispense cash-|   |         |<br>
                        |<--receipt-------|   |         |<br>
                        </code>
                    </div>
                </div>
            </div>
            
            <!-- Section 8: Activity Diagrams -->
            <div class="section">
                <div class="section-title">8. Activity Diagrams</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>Activity Diagram:</strong><br>
                        Shows workflow of a system - the flow of control from activity to activity. Similar to flowchart but more powerful.
                    </div>
                    
                    <div class="code-box"><strong>Activity Diagram Components:</strong>

‚Ä¢ Initial Node: Filled circle (start)
‚Ä¢ Activity: Rounded rectangle
‚Ä¢ Decision: Diamond (if-else)
‚Ä¢ Fork/Join: Thick bar (parallel activities)
‚Ä¢ Final Node: Circle with inner filled circle (end)
‚Ä¢ Transitions: Arrows connecting activities</div>
                    
                    <div class="example-box">
                        <strong>Example - Online Order Process:</strong><br>
                        <code>
                        ‚óè (Start)<br>
                        ‚Üì<br>
                        [Browse Products]<br>
                        ‚Üì<br>
                        [Add to Cart]<br>
                        ‚Üì<br>
                        ‚óá More items?<br>
                        Yes ‚Üí (back to Browse Products)<br>
                        No ‚Üì<br>
                        [Checkout]<br>
                        ‚Üì<br>
                        [Enter Details]<br>
                        ‚Üì<br>
                        ‚óá Valid details?<br>
                        No ‚Üí (back to Enter Details)<br>
                        Yes ‚Üì<br>
                        [Make Payment]<br>
                        ‚Üì<br>
                        ‚óá Payment successful?<br>
                        No ‚Üí [Cancel Order] ‚Üí ‚óâ (End)<br>
                        Yes ‚Üì<br>
                        [Confirm Order]<br>
                        ‚Üì<br>
                        [Send Email]<br>
                        ‚Üì<br>
                        ‚óâ (End)<br>
                        </code>
                    </div>
                </div>
            </div>
            
            <!-- Section 9: State Chart Diagrams -->
            <div class="section">
                <div class="section-title">9. State Chart Diagrams</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>State Chart Diagram:</strong><br>
                        Shows different states of an object and transitions between states based on events. Describes lifecycle of an object.
                    </div>
                    
                    <div class="code-box"><strong>State Chart Components:</strong>

‚Ä¢ State: Rounded rectangle
‚Ä¢ Initial State: Filled circle
‚Ä¢ Final State: Circle with inner filled circle
‚Ä¢ Transition: Arrow with event label
‚Ä¢ Event: Trigger causing transition
‚Ä¢ Guard: Condition in [brackets]</div>
                    
                    <div class="example-box">
                        <strong>Example - Order State Chart:</strong><br>
                        <code>
                        ‚óè ‚Üí [New Order]<br>
                        ‚Üì payment confirmed<br>
                        [Order Confirmed]<br>
                        ‚Üì item packed<br>
                        [Ready to Ship]<br>
                        ‚Üì picked by courier<br>
                        [In Transit]<br>
                        ‚Üì reached destination<br>
                        [Out for Delivery]<br>
                        ‚Üì delivered<br>
                        [Delivered] ‚Üí ‚óâ<br><br>
                        
                        Alternate: cancel order (from any state) ‚Üí [Cancelled] ‚Üí ‚óâ<br>
                        </code>
                    </div>
                </div>
            </div>
            
        </div>
        
        <!-- LAST MIN NOTES TAB -->
        <div class="tab-content" id="lastMinTab">
            <div class="chapter-title">
                <span>‚ö°</span>
                <span>Last Minute Notes - Quick Revision (5-10 mins)</span>
            </div>
            
            <div class="section">
                <div class="note-box">
                    <strong>üìå How to Use:</strong> Read this 5-10 minutes before exam for quick revision of all key concepts!
                </div>
            </div>
            
            <!-- Introduction -->
            <div class="section">
                <div class="section-title">üéØ Introduction</div>
                <div class="content">
                    <div class="code-box">Software = Programs + Documentation + Data

Software Engineering = Systematic approach to develop quality software

Need of SE:
‚Ä¢ Handle complexity
‚Ä¢ Ensure quality
‚Ä¢ Manage cost & time
‚Ä¢ Team collaboration
‚Ä¢ Maintainability

Program vs Product:
Program: For developer, minimal testing
Product: For users, tested, documented, maintained

SDLC Phases:
1. Planning
2. Requirement Analysis
3. Design
4. Implementation
5. Testing
6. Deployment
7. Maintenance</div>
                </div>
            </div>
            
            <!-- SDLC Models -->
            <div class="section">
                <div class="section-title">üîÑ SDLC Models</div>
                <div class="content">
                    <div class="code-box"><strong>1. Waterfall:</strong> Sequential, no going back
Use: Small projects, clear requirements

<strong>2. Iterative Waterfall:</strong> Can go back to previous phase
Better than Waterfall

<strong>3. Prototype:</strong> Build working model first
Use: Unclear requirements, complex UI

<strong>4. Evolutionary:</strong> Incremental versions
Example: v1.0 ‚Üí v2.0 ‚Üí v3.0

<strong>5. Spiral:</strong> Focus on risk analysis, 4 quadrants
Use: Large, risky projects

<strong>6. Agile:</strong> Flexible, 2-4 week sprints
Use: Changing requirements, startups

<strong>7. V-Model:</strong> Testing planned from start
Use: High reliability needed</div>
                </div>
            </div>
            
            <!-- Requirements -->
            <div class="section">
                <div class="section-title">üìã Requirements</div>
                <div class="content">
                    <div class="code-box"><strong>Requirement Types:</strong>
‚Ä¢ Functional: What system does
‚Ä¢ Non-Functional: How well it performs

<strong>Analysis Principles:</strong>
1. Information Domain
2. Functional
3. Behavioral
4. Partition
5. Essential vs Implementation

<strong>SRS Characteristics:</strong>
1. Correct
2. Unambiguous
3. Complete
4. Consistent
5. Ranked
6. Verifiable
7. Modifiable
8. Traceable

<strong>Data Modelling:</strong> ER diagrams (Entity-Relationship)
‚Ä¢ Entity: Real-world object
‚Ä¢ Attribute: Property
‚Ä¢ Relationship: Association

<strong>DFD Components:</strong>
‚Ä¢ Process: Circle
‚Ä¢ Data Flow: Arrow
‚Ä¢ Data Store: Parallel lines
‚Ä¢ External Entity: Rectangle

<strong>Behavioral Modelling:</strong> State Transition Diagrams
‚Ä¢ Shows states and transitions

<strong>Structural Modelling:</strong>
‚Ä¢ High Cohesion (Good): Related functions together
‚Ä¢ Low Coupling (Good): Independent modules

<strong>Data Dictionary:</strong> Definitions of all data elements</div>
                </div>
            </div>
            
            <!-- OOP -->
            <div class="section">
                <div class="section-title">üé® Object-Oriented Concepts</div>
                <div class="content">
                    <div class="code-box"><strong>Core OOP Concepts:</strong>

1. Class: Blueprint
2. Object: Instance of class
3. Encapsulation: Data hiding
4. Inheritance: Parent ‚Üí Child (code reuse)
5. Polymorphism: Same name, different behavior
6. Abstraction: Hide complexity

<strong>Advantages:</strong>
‚Ä¢ Code reusability
‚Ä¢ Easy maintenance
‚Ä¢ Data security
‚Ä¢ Flexibility</div>
                </div>
            </div>
            
            <!-- UML -->
            <div class="section">
                <div class="section-title">üìä UML Diagrams</div>
                <div class="content">
                    <div class="code-box"><strong>UML Diagram Types:</strong>

<strong>Structural:</strong>
‚Ä¢ Class Diagram (most important)
‚Ä¢ Object Diagram
‚Ä¢ Component Diagram

<strong>Behavioral:</strong>
‚Ä¢ Use Case Diagram (requirements)
‚Ä¢ Activity Diagram (workflow)
‚Ä¢ State Diagram (states)
‚Ä¢ Sequence Diagram (interactions)

<strong>Use Case Components:</strong>
‚Ä¢ Actor: Stick figure
‚Ä¢ Use Case: Oval
‚Ä¢ Include: <<include>> (mandatory)
‚Ä¢ Extend: <<extend>> (optional)

<strong>Class Diagram Relationships:</strong>
‚Ä¢ Association: ‚Äî‚Äî‚Äî
‚Ä¢ Aggregation: ‚óá‚Äî‚Äî‚Äî (weak has-a)
‚Ä¢ Composition: ‚óÜ‚Äî‚Äî‚Äî (strong has-a)
‚Ä¢ Inheritance: ‚ñ≥‚Äî‚Äî‚Äî (is-a)
‚Ä¢ Dependency: ---‚Üí (uses)

<strong>Multiplicity:</strong>
1 = one, * = many, 0..1 = optional, 1..* = one or more

<strong>Activity Diagram:</strong>
‚Ä¢ Shows workflow
‚Ä¢ Start: ‚óè
‚Ä¢ Activity: Rounded rectangle
‚Ä¢ Decision: ‚óá
‚Ä¢ End: ‚óâ

<strong>State Diagram:</strong>
‚Ä¢ Shows object lifecycle
‚Ä¢ State changes based on events

<strong>Sequence Diagram:</strong>
‚Ä¢ Shows time-ordered interactions
‚Ä¢ Objects at top, messages as arrows</div>
                </div>
            </div>
            
            <!-- Important Points -->
            <div class="section">
                <div class="section-title">‚ö†Ô∏è Common Exam Topics</div>
                <div class="content">
                    <div class="threat-box">
                        <strong>Must Remember:</strong><br>
                        ‚ùå Waterfall vs Agile differences<br>
                        ‚ùå When to use which SDLC model<br>
                        ‚ùå SRS characteristics (all 8)<br>
                        ‚ùå DFD symbols and levels<br>
                        ‚ùå OOP concepts with examples<br>
                        ‚ùå Class diagram relationships<br>
                        ‚ùå Use Case include vs extend<br>
                        ‚ùå High cohesion + Low coupling = Good design<br>
                        ‚ùå Functional vs Non-functional requirements
                    </div>
                </div>
            </div>
            
            <!-- Formulas & Key Points -->
            <div class="section">
                <div class="section-title">üìê Key Points to Remember</div>
                <div class="content">
                    <div class="advantage-box">
                        ‚úì 60-70% software failures due to poor requirements<br>
                        ‚úì 60-70% cost is in maintenance phase<br>
                        ‚úì Software Crisis occurred in 1960s-1970s<br>
                        ‚úì IEEE 830 standard for SRS<br>
                        ‚úì Agile: 2-4 week sprints<br>
                        ‚úì Spiral: 4 quadrants (Plan, Risk, Develop, Evaluate)<br>
                        ‚úì UML = Unified Modelling Language<br>
                        ‚úì ER Model: Entity-Relationship<br>
                        ‚úì DFD: Data Flow Diagram (3 levels: 0, 1, 2)
                    </div>
                </div>
            </div>
            
            <!-- Comparison Tables -->
            <div class="section">
                <div class="section-title">üìä Quick Comparison Tables</div>
                <div class="content">
                    <div class="code-box"><strong>SDLC Models Comparison:</strong>

Model      | Flexibility | When to Use
---------- | ----------- | -----------
Waterfall  | Low         | Small, clear requirements
Agile      | Very High   | Changing requirements
Spiral     | High        | Large, risky projects
Prototype  | High        | Unclear requirements
V-Model    | Low         | High reliability needed

<strong>Structured vs OOP:</strong>

Aspect     | Structured  | OOP
---------- | ----------- | -----------
Focus      | Functions   | Objects
Approach   | Top-Down    | Bottom-Up
Data       | Separate    | With methods
Reuse      | Limited     | High (Inheritance)

<strong>Aggregation vs Composition:</strong>

Feature    | Aggregation | Composition
---------- | ----------- | -----------
Strength   | Weak        | Strong
Part exist | Yes         | No
alone?     |             |
Example    | Dept-Student| House-Room</div>
                </div>
            </div>
            
            <!-- Diagram Drawing Tips -->
            <div class="section">
                <div class="section-title">‚úèÔ∏è Diagram Drawing Tips</div>
                <div class="content">
                    <div class="step-box">
                        <strong>DFD:</strong><br>
                        ‚Ä¢ Start with Context Diagram (Level 0)<br>
                        ‚Ä¢ Use proper symbols<br>
                        ‚Ä¢ Label all flows<br>
                        ‚Ä¢ Balance inputs/outputs<br><br>
                        
                        <strong>Class Diagram:</strong><br>
                        ‚Ä¢ Show 3 compartments (Name, Attributes, Methods)<br>
                        ‚Ä¢ Use visibility symbols (+, -, #)<br>
                        ‚Ä¢ Show relationships with correct symbols<br>
                        ‚Ä¢ Add multiplicity<br><br>
                        
                        <strong>Use Case:</strong><br>
                        ‚Ä¢ Actor as stick figure<br>
                        ‚Ä¢ Use cases as ovals<br>
                        ‚Ä¢ Draw system boundary box<br>
                        ‚Ä¢ Use <<include>> and <<extend>> correctly<br><br>
                        
                        <strong>Activity Diagram:</strong><br>
                        ‚Ä¢ Start with ‚óè (filled circle)<br>
                        ‚Ä¢ Activities as rounded rectangles<br>
                        ‚Ä¢ Decisions as diamonds<br>
                        ‚Ä¢ End with ‚óâ (double circle)
                    </div>
                </div>
            </div>
            
            <!-- Exam Strategy -->
            <div class="section">
                <div class="section-title">üí° Exam Strategy</div>
                <div class="content">
                    <div class="example-box">
                        <strong>For Theory Questions:</strong><br>
                        ‚Ä¢ Define clearly<br>
                        ‚Ä¢ Give real-life example<br>
                        ‚Ä¢ List advantages/disadvantages<br>
                        ‚Ä¢ Compare if asked<br><br>
                        
                        <strong>For Diagram Questions:</strong><br>
                        ‚Ä¢ Use correct symbols<br>
                        ‚Ä¢ Label everything<br>
                        ‚Ä¢ Keep it neat and readable<br>
                        ‚Ä¢ Show all relationships<br><br>
                        
                        <strong>For Model Questions:</strong><br>
                        ‚Ä¢ Explain phases<br>
                        ‚Ä¢ Draw diagram if possible<br>
                        ‚Ä¢ Mention advantages/disadvantages<br>
                        ‚Ä¢ Give when to use<br><br>
                        
                        <strong>Time Management:</strong><br>
                        ‚Ä¢ Read all questions first<br>
                        ‚Ä¢ Start with easy ones<br>
                        ‚Ä¢ Allocate time per question<br>
                        ‚Ä¢ Keep 10 mins for revision
                    </div>
                </div>
            </div>
            
            <!-- Final Tips -->
            <div class="section">
                <div class="section-title">üåü Final Tips</div>
                <div class="content">
                    <div class="note-box" style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.1) 0%, rgba(59, 130, 246, 0.1) 100%); border-left: 4px solid var(--success);">
                        <strong>Remember:</strong><br>
                        ‚Ä¢ Software Engineering is about systematic approach<br>
                        ‚Ä¢ Choose right SDLC model based on project needs<br>
                        ‚Ä¢ Requirements are foundation - get them right!<br>
                        ‚Ä¢ UML diagrams = Visual communication<br>
                        ‚Ä¢ OOP principles = Better software design<br><br>
                        
                        <strong>üéØ All the Best!</strong><br>
                        You've covered everything! Focus on understanding concepts, not just memorizing. Practice drawing diagrams. You'll do great! üí™üöÄ
                    </div>
                </div>
            </div>
            
        </div>
        
    </div>
    
    <!-- Footer -->
    <div class="footer">
        <div class="footer-credit">
            Made with üíô by <strong>Ankush Raj</strong>
        </div>
        <p class="footer-note">
            ¬© 2026 <a href="https://ankushraj.dev" target="_blank" style="color: var(--primary); text-decoration: none; font-weight: 600;">ankushraj.dev</a> - All Rights Reserved
        </p>
    </div>
    
    <script>
        // Dark Mode Toggle
        const darkModeBtn = document.getElementById('darkModeBtn');
        const isDarkMode = localStorage.getItem('darkMode') === 'true';
        
        if (isDarkMode) {
            document.body.classList.add('dark-mode');
            updateDarkModeBtn(true);
        }
        
        function toggleDarkMode() {
            document.body.classList.toggle('dark-mode');
            const isDark = document.body.classList.contains('dark-mode');
            localStorage.setItem('darkMode', isDark);
            updateDarkModeBtn(isDark);
        }
        
        function updateDarkModeBtn(isDark) {
            const btn = document.getElementById('darkModeBtn');
            btn.innerHTML = isDark 
                ? '<span>‚òÄÔ∏è</span><span>Light</span>' 
                : '<span>üåô</span><span>Dark</span>';
        }
        
        // TOC Toggle
        function openTOC() {
            document.getElementById('tocPanel').classList.add('active');
            document.getElementById('overlay').classList.add('active');
        }
        
        function closeTOC() {
            document.getElementById('tocPanel').classList.remove('active');
            document.getElementById('overlay').classList.remove('active');
        }
        
        // Tab Switching
        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            if (tabName === 'full') {
                document.querySelectorAll('.tab')[0].classList.add('active');
                document.getElementById('fullNotesTab').classList.add('active');
            } else {
                document.querySelectorAll('.tab')[1].classList.add('active');
                document.getElementById('lastMinTab').classList.add('active');
            }
            
            window.scrollTo({top: 0, behavior: 'smooth'});
        }
        
        // Build TOC
        const chapters = [
            { title: 'Introduction to SE', id: 'ch1' },
            { title: 'Software Requirements', id: 'ch2' },
            { title: 'Object Oriented Design', id: 'ch3' }
        ];
        
        const tocList = document.getElementById('tocList');
        chapters.forEach((ch, index) => {
            const li = document.createElement('li');
            li.innerHTML = `<span style="color: var(--primary); font-weight: 700;">${index + 1}.</span> ${ch.title}`;
            li.onclick = () => {
                const element = document.getElementById(ch.id);
                if (element) {
                    element.scrollIntoView({ behavior: 'smooth' });
                }
                closeTOC();
            };
            tocList.appendChild(li);
        });
    </script>
</body>
</html>