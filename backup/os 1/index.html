<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Operating System - Unit 1 | ankushraj.dev</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --primary: #3b82f6;
            --secondary: #8b5cf6;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --text: #333;
            --text-light: #6b7280;
            --bg: #f5f7fa;
            --card-bg: #ffffff;
            --border: #e5e7eb;
            --code-bg: #f3f4f6;
        }
        
        body.dark-mode {
            --text: #f0f0f0;
            --text-light: #9ca3af;
            --bg: #111827;
            --card-bg: #1f2937;
            --border: #374151;
            --code-bg: #374151;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
            transition: background 0.3s, color 0.3s;
        }
        
        /* Print Styles */
        @media print {
            @page {
                margin: 15mm 10mm 12mm 10mm;
                size: A4;
            }
            
            body {
                font-size: 13px;
                line-height: 1.45;
            }
            
            body::before {
                content: "ankushraj.dev";
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%) rotate(-45deg);
                font-size: 70px;
                font-weight: 200;
                color: rgba(0, 0, 0, 0.04);
                z-index: -1;
            }
            
            .header-controls, .tabs-container, .toc-panel, .overlay {
                display: none !important;
            }
        }
        
        /* Header */
        .header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
            padding: 12px 16px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .header-title {
            text-align: center;
        }
        
        .header-title h1 {
            font-size: 24px;
            font-weight: 800;
            margin-bottom: 4px;
        }
        
        .header-title p {
            font-size: 14px;
            opacity: 0.9;
        }
        
        .header-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 12px;
        }
        
        .btn {
            flex: 1;
            max-width: 150px;
            padding: 10px 16px;
            border: none;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.25);
            color: white;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }
        
        .btn:hover {
            background: rgba(255, 255, 255, 0.35);
            transform: translateY(-2px);
        }
        
        /* Tabs */
        .tabs-container {
            background: var(--card-bg);
            border-bottom: 2px solid var(--border);
            display: flex;
        }
        
        .tab {
            flex: 1;
            padding: 16px;
            text-align: center;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            color: var(--text-light);
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }
        
        .tab.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
            background: rgba(59, 130, 246, 0.05);
        }
        
        /* TOC Panel */
        .toc-panel {
            display: none;
            position: fixed;
            left: 0;
            top: 0;
            width: 85%;
            max-width: 320px;
            height: 100vh;
            background: var(--card-bg);
            z-index: 1000;
            overflow-y: auto;
            box-shadow: 4px 0 12px rgba(0,0,0,0.2);
            transform: translateX(-100%);
            transition: transform 0.3s ease;
        }
        
        .toc-panel.active {
            display: block;
            transform: translateX(0);
        }
        
        .toc-header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
            padding: 16px;
            font-size: 16px;
            font-weight: 700;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .toc-close {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            font-size: 18px;
            cursor: pointer;
        }
        
        .toc-list {
            list-style: none;
            padding: 0;
        }
        
        .toc-list li {
            padding: 14px 16px;
            font-size: 13px;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .toc-list li:hover {
            background: var(--bg);
            color: var(--primary);
            padding-left: 24px;
        }
        
        /* Overlay */
        .overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 999;
        }
        
        .overlay.active {
            display: block;
        }
        
        /* Container */
        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 12px;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
            animation: fadeIn 0.4s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .chapter-title {
            font-size: 18px;
            font-weight: 800;
            color: white;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            padding: 14px 16px;
            margin-bottom: 16px;
            margin-left: -12px;
            margin-right: -12px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .section {
            margin-bottom: 24px;
        }
        
        .section-title {
            font-size: 16px;
            font-weight: 700;
            color: var(--primary);
            margin-bottom: 10px;
            padding-bottom: 6px;
            border-bottom: 2px solid var(--primary);
        }
        
        .subsection-title {
            font-size: 14px;
            font-weight: 700;
            color: var(--text);
            margin-top: 12px;
            margin-bottom: 6px;
        }
        
        .content p {
            margin-bottom: 10px;
            font-size: 14px;
            line-height: 1.65;
        }
        
        /* Content Boxes */
        .definition-box, .code-box, .advantage-box, .threat-box, 
        .step-box, .example-box, .mindmap-box, .note-box, .formula-box {
            padding: 12px;
            border-radius: 8px;
            margin: 10px 0;
            font-size: 13px;
            line-height: 1.65;
        }
        
        .definition-box {
            background: rgba(59, 130, 246, 0.1);
            border-left: 4px solid var(--primary);
        }
        
        .code-box {
            background: var(--code-bg);
            border-left: 4px solid #6b7280;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
            white-space: pre-wrap;
        }
        
        .advantage-box {
            background: rgba(16, 185, 129, 0.1);
            border-left: 4px solid var(--success);
        }
        
        .threat-box {
            background: rgba(239, 68, 68, 0.1);
            border-left: 4px solid var(--danger);
        }
        
        .step-box {
            background: rgba(245, 158, 11, 0.1);
            border-left: 4px solid var(--warning);
        }
        
        .example-box {
            background: rgba(139, 92, 246, 0.1);
            border-left: 4px solid var(--secondary);
        }
        
        .mindmap-box {
            background: rgba(139, 92, 246, 0.05);
            border: 2px dashed var(--secondary);
            text-align: center;
            padding: 20px;
        }
        
        .note-box {
            background: rgba(245, 158, 11, 0.1);
            border-left: 4px solid var(--warning);
        }
        
        .formula-box {
            background: rgba(139, 92, 246, 0.1);
            border-left: 4px solid var(--secondary);
            font-family: 'Courier New', monospace;
        }
        
        .point {
            margin-left: 18px;
            margin-bottom: 6px;
            font-size: 13px;
            position: relative;
        }
        
        .point::before {
            content: "â€¢";
            position: absolute;
            left: -14px;
            color: var(--primary);
            font-weight: 700;
        }
        
        .divider {
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--border), transparent);
            margin: 24px 0;
        }
        
        /* Footer */
        .footer {
            text-align: center;
            padding: 16px;
            background: var(--card-bg);
            border-top: 2px solid var(--border);
            margin-top: 32px;
        }
        
        .footer-credit {
            font-size: 14px;
            color: var(--text);
            font-weight: 600;
        }
        
        .footer-credit strong {
            color: var(--primary);
        }
        
        .footer-note {
            font-size: 11px;
            color: var(--text-light);
            margin-top: 4px;
        }
        
        /* Responsive */
        @media (min-width: 768px) {
            .container { padding: 16px; }
            .header { padding: 14px 20px; }
            .header-title h1 { font-size: 28px; }
            .chapter-title { font-size: 20px; padding: 16px 20px; }
            .section-title { font-size: 18px; }
            .content p { font-size: 15px; }
        }
    </style>
</head>
<body>
    <!-- TOC Panel -->
    <div class="toc-panel" id="tocPanel">
        <div class="toc-header">
            <span>ğŸ“š Chapters</span>
            <button class="toc-close" onclick="closeTOC()">Ã—</button>
        </div>
        <ul class="toc-list" id="tocList"></ul>
    </div>
    
    <!-- Overlay -->
    <div class="overlay" id="overlay" onclick="closeTOC()"></div>
    
    <!-- Header -->
    <div class="header">
        <div class="header-title">
            <h1>Operating System</h1>
            <p>Unit 1 - Introduction & Process Management</p>
        </div>
        
        <div class="header-controls">
            <button class="btn" onclick="openTOC()">
                <span>ğŸ“‘</span><span>Chapters</span>
            </button>
            <button class="btn" id="darkModeBtn" onclick="toggleDarkMode()">
                <span>ğŸŒ™</span><span>Dark</span>
            </button>
            <button class="btn" onclick="window.print()">
                <span>ğŸ“¥</span><span>PDF</span>
            </button>
        </div>
    </div>
    
    <!-- Tabs -->
    <div class="tabs-container">
        <div class="tab active" onclick="switchTab('full')">ğŸ“– Full Notes</div>
        <div class="tab" onclick="switchTab('lastmin')">âš¡ Last Min Notes</div>
    </div>
    
    <!-- Content -->
    <div class="container">
        <!-- FULL NOTES TAB -->
        <div class="tab-content active" id="fullNotesTab">
            
            <!-- CHAPTER 1: INTRODUCTION TO OS -->
            <div class="chapter-title" id="ch1">
                <span>ğŸ’»</span>
                <span>Chapter 1 â€” Introduction to Operating System</span>
            </div>
            
            <!-- Mind Map -->
            <div class="section">
                <div class="mindmap-box">
                    <strong style="color: var(--secondary); font-size: 16px;">ğŸ“Š OPERATING SYSTEM - MIND MAP</strong>
                    <div style="margin-top: 15px; text-align: left; max-width: 700px; margin-left: auto; margin-right: auto;">
                        <div class="point">OS â†’ Software that manages hardware and provides services to applications</div>
                        <div class="point">Structure â†’ Monolithic, Layered, Microkernel, Modular</div>
                        <div class="point">Functions â†’ Process, Memory, File, I/O, Security Management</div>
                        <div class="point">Types â†’ Batch, Time-sharing, Real-time, Distributed, Mobile</div>
                        <div class="point">System Calls â†’ Interface between user programs and OS kernel</div>
                        <div class="point">Process â†’ Program in execution with PCB and states</div>
                    </div>
                </div>
            </div>
            
            <!-- Section 1: What is OS -->
            <div class="section">
                <div class="section-title">1. Introduction to Operating Systems</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>Operating System (OS):</strong><br>
                        An Operating System is system software that acts as an intermediary between computer hardware and user applications. It manages hardware resources and provides services to application programs.
                    </div>
                    
                    <div class="example-box">
                        <strong>Real-life Example - Restaurant Manager:</strong><br>
                        Think of OS like a restaurant manager:<br>
                        â€¢ <strong>Customers (Users/Applications)</strong> want food<br>
                        â€¢ <strong>Kitchen (Hardware)</strong> cooks the food<br>
                        â€¢ <strong>Manager (OS)</strong> takes orders, assigns tasks to chefs, manages kitchen equipment, ensures everything runs smoothly<br><br>
                        Just like manager coordinates between customers and kitchen, OS coordinates between applications and hardware!
                    </div>
                    
                    <div class="subsection-title">Goals of Operating System:</div>
                    <div class="advantage-box">
                        <strong>1. Convenience:</strong> Make computer easy to use (GUI, commands)<br>
                        <strong>2. Efficiency:</strong> Use hardware resources efficiently<br>
                        <strong>3. Resource Management:</strong> Manage CPU, memory, storage, I/O devices<br>
                        <strong>4. Security:</strong> Protect data and prevent unauthorized access<br>
                        <strong>5. Reliability:</strong> Ensure system works correctly without failures
                    </div>
                    
                    <div class="subsection-title">Components of Computer System:</div>
                    <div class="code-box"><strong>4 Components:</strong>

1. Hardware (Bottom Layer)
   CPU, Memory, Disk, I/O devices
   
2. Operating System (Middle Layer)
   Controls hardware, provides services
   
3. Application Programs (Upper Layer)
   Word processors, browsers, games
   
4. Users (Top Layer)
   People, other computers, machines</div>
                    
                    <div class="note-box">
                        <strong>Key Point:</strong> OS is the only program that runs at all times on the computer (called the <strong>kernel</strong>). Everything else is either a system program or application program.
                    </div>
                </div>
            </div>
            
            <!-- Section 2: OS Structure -->
            <div class="section">
                <div class="section-title">2. Operating System Structure</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>OS Structure:</strong><br>
                        The way an operating system organizes its components and how they interact with each other.
                    </div>
                    
                    <div class="subsection-title">Types of OS Structures:</div>
                    
                    <div class="step-box">
                        <strong>1. Monolithic Structure:</strong><br>
                        All OS services run in kernel mode as a single large program.<br><br>
                        <strong>Characteristics:</strong><br>
                        â€¢ No structure - everything in one big program<br>
                        â€¢ All functions have access to all data<br>
                        â€¢ Fast (no overhead of communication)<br><br>
                        <strong>Example:</strong> MS-DOS, Early UNIX<br><br>
                        <strong>Advantages:</strong> âœ“ Fast, âœ“ Simple<br>
                        <strong>Disadvantages:</strong> âœ— Hard to maintain, âœ— One bug crashes entire system
                    </div>
                    
                    <div class="step-box">
                        <strong>2. Layered Structure:</strong><br>
                        OS divided into layers, each layer uses services of layer below it.<br><br>
                        <strong>Layers (Bottom to Top):</strong><br>
                        Layer 0: Hardware<br>
                        Layer 1: CPU Scheduling<br>
                        Layer 2: Memory Management<br>
                        Layer 3: I/O Management<br>
                        Layer 4: User Programs<br><br>
                        <strong>Example:</strong> THE OS, Windows NT<br><br>
                        <strong>Advantages:</strong> âœ“ Easy to debug (layer by layer), âœ“ Modular<br>
                        <strong>Disadvantages:</strong> âœ— Slow (many layers), âœ— Hard to define layers
                    </div>
                    
                    <div class="step-box">
                        <strong>3. Microkernel Structure:</strong><br>
                        Only essential services in kernel, rest run as user processes.<br><br>
                        <strong>Kernel Contains:</strong><br>
                        â€¢ Minimal process management<br>
                        â€¢ Memory management<br>
                        â€¢ Inter-process communication (IPC)<br><br>
                        <strong>User Space Contains:</strong><br>
                        â€¢ File system<br>
                        â€¢ Device drivers<br>
                        â€¢ Network protocols<br><br>
                        <strong>Example:</strong> Mach, QNX, Minix<br><br>
                        <strong>Advantages:</strong> âœ“ Reliable (less code in kernel), âœ“ Easy to extend<br>
                        <strong>Disadvantages:</strong> âœ— Slower (frequent message passing)
                    </div>
                    
                    <div class="step-box">
                        <strong>4. Modular Structure (Loadable Kernel Modules):</strong><br>
                        Modern approach - kernel has core components, others loaded as modules.<br><br>
                        <strong>How it works:</strong><br>
                        â€¢ Core kernel is small<br>
                        â€¢ Modules loaded dynamically when needed<br>
                        â€¢ Each module talks to core via defined interfaces<br><br>
                        <strong>Example:</strong> Linux, Solaris<br><br>
                        <strong>Advantages:</strong> âœ“ Flexible, âœ“ Efficient, âœ“ Easy to add features<br>
                        <strong>Best of both:</strong> Speed of monolithic + modularity of layers
                    </div>
                </div>
            </div>
            
            <!-- Section 3: Main Functions -->
            <div class="section">
                <div class="section-title">3. Main Functions of Operating System</div>
                <div class="content">
                    <div class="subsection-title">1. Process Management:</div>
                    <div class="example-box">
                        <strong>What is Process Management?</strong><br>
                        Managing programs that are currently running (processes).<br><br>
                        <strong>OS Responsibilities:</strong><br>
                        â€¢ Create and delete processes<br>
                        â€¢ Suspend and resume processes<br>
                        â€¢ Provide mechanisms for process synchronization<br>
                        â€¢ Provide mechanisms for process communication<br>
                        â€¢ Handle deadlocks<br><br>
                        <strong>Example:</strong> When you open Chrome, Word, and Spotify together, OS manages all three processes, decides which gets CPU time, and ensures they don't interfere with each other.
                    </div>
                    
                    <div class="subsection-title">2. Memory Management:</div>
                    <div class="example-box">
                        <strong>What is Memory Management?</strong><br>
                        Managing computer's RAM (main memory).<br><br>
                        <strong>OS Responsibilities:</strong><br>
                        â€¢ Keep track of which memory is used and by whom<br>
                        â€¢ Decide which processes to load in memory<br>
                        â€¢ Allocate and deallocate memory<br>
                        â€¢ Prevent processes from accessing each other's memory<br><br>
                        <strong>Example:</strong> If you have 8GB RAM and run programs needing 10GB, OS uses virtual memory (hard disk space) to manage the extra 2GB.
                    </div>
                    
                    <div class="subsection-title">3. File Management:</div>
                    <div class="example-box">
                        <strong>What is File Management?</strong><br>
                        Managing files and directories on storage devices.<br><br>
                        <strong>OS Responsibilities:</strong><br>
                        â€¢ Create and delete files and directories<br>
                        â€¢ Provide operations on files (read, write, append)<br>
                        â€¢ Map files to disk storage<br>
                        â€¢ Backup files<br>
                        â€¢ Provide file permissions and security<br><br>
                        <strong>Example:</strong> When you save a document, OS decides where on the hard disk to store it, updates directory structure, and manages file permissions.
                    </div>
                    
                    <div class="subsection-title">4. I/O Device Management:</div>
                    <div class="example-box">
                        <strong>What is I/O Management?</strong><br>
                        Managing input/output devices (keyboard, mouse, printer, etc.)<br><br>
                        <strong>OS Responsibilities:</strong><br>
                        â€¢ Provide device drivers<br>
                        â€¢ Buffer and cache data<br>
                        â€¢ Handle I/O operations<br>
                        â€¢ Manage device queues<br><br>
                        <strong>Example:</strong> When you print a document, OS uses printer driver to communicate with printer, manages print queue if multiple documents are waiting.
                    </div>
                    
                    <div class="subsection-title">5. Security and Protection:</div>
                    <div class="example-box">
                        <strong>What is Security?</strong><br>
                        Protecting system from unauthorized access and threats.<br><br>
                        <strong>OS Responsibilities:</strong><br>
                        â€¢ User authentication (passwords, biometrics)<br>
                        â€¢ Access control (file permissions)<br>
                        â€¢ Protect processes from each other<br>
                        â€¢ Defend against viruses and malware<br><br>
                        <strong>Example:</strong> Login password, file permissions (who can read/write/execute), preventing one user from accessing another user's files.
                    </div>
                </div>
            </div>
            
            <!-- Section 4: Characteristics -->
            <div class="section">
                <div class="section-title">4. Characteristics of Operating System</div>
                <div class="content">
                    <div class="advantage-box">
                        <strong>1. Resource Manager:</strong><br>
                        OS manages all hardware resources (CPU, memory, I/O devices) efficiently.<br><br>
                        
                        <strong>2. Interface Provider:</strong><br>
                        Provides user-friendly interface (GUI or Command Line) to interact with computer.<br><br>
                        
                        <strong>3. Multitasking:</strong><br>
                        Run multiple programs simultaneously.<br>
                        Example: Listen to music while browsing and typing document.<br><br>
                        
                        <strong>4. Multiprogramming:</strong><br>
                        Keep multiple programs in memory and execute them by switching.<br><br>
                        
                        <strong>5. Time Sharing:</strong><br>
                        Multiple users can use the system simultaneously.<br>
                        Example: Multiple users logged into a server.<br><br>
                        
                        <strong>6. Error Handling:</strong><br>
                        Detect and handle errors (hardware failure, division by zero, etc.)<br><br>
                        
                        <strong>7. Memory Protection:</strong><br>
                        Prevent processes from accessing memory they shouldn't.<br><br>
                        
                        <strong>8. Job Scheduling:</strong><br>
                        Decide which process runs when and for how long.
                    </div>
                </div>
            </div>
            
            <div class="divider"></div>
            
            <!-- Section 5: Types of OS -->
            <div class="section">
                <div class="section-title">5. Types of Operating Systems</div>
                <div class="content">
                    <div class="subsection-title">1. Batch Operating System:</div>
                    <div class="example-box">
                        <strong>Batch OS:</strong> Jobs grouped and executed without user interaction<br><br>
                        
                        <strong>Real-life Example:</strong> Bank processes all checks in one batch at night<br><br>
                        
                        <strong>Advantages:</strong> âœ“ High throughput âœ“ Less CPU idle time<br>
                        <strong>Disadvantages:</strong> âœ— No interaction âœ— Long waiting
                    </div>
                    
                    <div class="subsection-title">2. Time-Sharing OS (Multitasking):</div>
                    <div class="example-box">
                        <strong>Time-Sharing:</strong> Multiple users share CPU by time slicing<br><br>
                        
                        <strong>How:</strong> CPU gives small time to each process, switches rapidly<br><br>
                        
                        <strong>Examples:</strong> Windows, Linux, macOS<br><br>
                        
                        <strong>Advantages:</strong> âœ“ Multiple users âœ“ Quick response<br>
                        <strong>Disadvantages:</strong> âœ— Context switching overhead
                    </div>
                    
                    <div class="subsection-title">3. Real-Time OS (RTOS):</div>
                    <div class="step-box">
                        <strong>Hard Real-Time:</strong> Deadline must be met (Airbag, Pacemaker)<br>
                        <strong>Soft Real-Time:</strong> Deadline can be missed occasionally (Video streaming)<br><br>
                        
                        <strong>Advantages:</strong> âœ“ Guaranteed response âœ“ High reliability<br>
                        <strong>Disadvantages:</strong> âœ— Complex âœ— Expensive
                    </div>
                    
                    <div class="subsection-title">4. Distributed OS:</div>
                    <div class="example-box">
                        <strong>Distributed:</strong> Multiple computers appear as one system<br><br>
                        
                        <strong>Example:</strong> Google servers working together<br><br>
                        
                        <strong>Advantages:</strong> âœ“ Reliability âœ“ Scalability<br>
                        <strong>Disadvantages:</strong> âœ— Complex âœ— Security
                    </div>
                    
                    <div class="subsection-title">5. Mobile OS:</div>
                    <div class="example-box">
                        <strong>Mobile:</strong> OS for smartphones/tablets<br>
                        <strong>Examples:</strong> Android, iOS<br>
                        <strong>Features:</strong> Touch interface, Battery optimization
                    </div>
                </div>
            </div>
            
            <!-- Section 6: System Calls -->
            <div class="section">
                <div class="section-title">6. System Calls</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>System Call:</strong> Interface between user program and OS kernel. Programs request OS services through system calls.
                    </div>
                    
                    <div class="code-box"><strong>How System Call Works:</strong>

1. User Program â†’ Calls library function
2. Mode Switch â†’ User mode to Kernel mode
3. OS Kernel â†’ Executes service
4. Return Result â†’ Back to user program
5. Mode Switch â†’ Kernel mode to User mode

<strong>User Mode:</strong> Limited privileges, cannot access hardware
<strong>Kernel Mode:</strong> Full privileges, can access everything</div>
                </div>
            </div>
            
            <!-- Section 7: Types of System Calls -->
            <div class="section">
                <div class="section-title">7. Types of System Calls</div>
                <div class="content">
                    <div class="code-box"><strong>5 Categories:</strong>

1. Process Control: fork(), exit(), wait(), exec()
2. File Management: open(), read(), write(), close()
3. Device Management: read(), write(), ioctl()
4. Information Maintenance: getpid(), time(), date()
5. Communication: send(), receive(), pipe(), socket()</div>
                </div>
            </div>
            
            <!-- Section 8: System Programs -->
            <div class="section">
                <div class="section-title">8. System Programs</div>
                <div class="content">
                    <div class="step-box">
                        <strong>System Programs:</strong> Utilities provided with OS<br><br>
                        
                        <strong>Types:</strong><br>
                        1. File Management (File explorer)<br>
                        2. Status Information (Task Manager)<br>
                        3. File Modification (Text editors)<br>
                        4. Programming Support (Compilers)<br>
                        5. Program Loading (Loaders)<br>
                        6. Communications (Email, FTP)<br>
                        7. Background Services (Antivirus)
                    </div>
                </div>
            </div>
            
            <div class="divider"></div>
            
            <!-- CHAPTER 2: PROCESS MANAGEMENT -->
            <div class="chapter-title" id="ch2">
                <span>âš™ï¸</span>
                <span>Chapter 2 â€” Process Management</span>
            </div>
            
            <!-- Section 1: Process Concept -->
            <div class="section">
                <div class="section-title">1. Process Concept</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>Process:</strong><br>
                        A process is a program in execution. When a program (stored on disk) is loaded into memory and executed, it becomes a process.
                    </div>
                    
                    <div class="example-box">
                        <strong>Program vs Process:</strong><br><br>
                        
                        <strong>Program:</strong><br>
                        â€¢ Passive entity (just code stored on disk)<br>
                        â€¢ Example: Chrome.exe file on hard disk<br>
                        â€¢ Static (doesn't change)<br><br>
                        
                        <strong>Process:</strong><br>
                        â€¢ Active entity (program running in memory)<br>
                        â€¢ Example: Chrome browser running on your screen<br>
                        â€¢ Dynamic (state changes during execution)<br><br>
                        
                        <strong>Analogy:</strong><br>
                        Program = Recipe book (inactive)<br>
                        Process = Cooking using recipe (active)
                    </div>
                    
                    <div class="subsection-title">Components of a Process:</div>
                    <div class="code-box"><strong>Process Memory Layout:</strong>

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â† High Address
â”‚  Stack          â”‚  Function calls, local variables
â”‚  â†“ (grows down) â”‚  
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  (free space)   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â†‘ (grows up)   â”‚
â”‚  Heap           â”‚  Dynamic memory (malloc)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Data           â”‚  Global/static variables
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Text           â”‚  Program code (instructions)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â† Low Address</div>
                    
                    <div class="step-box">
                        <strong>1. Text Section (Code):</strong><br>
                        â€¢ Contains executable code (instructions)<br>
                        â€¢ Read-only (cannot be modified)<br><br>
                        
                        <strong>2. Data Section:</strong><br>
                        â€¢ Global variables<br>
                        â€¢ Static variables<br><br>
                        
                        <strong>3. Heap:</strong><br>
                        â€¢ Dynamically allocated memory<br>
                        â€¢ Grows upward during execution<br>
                        â€¢ Managed by programmer (malloc/free)<br><br>
                        
                        <strong>4. Stack:</strong><br>
                        â€¢ Function calls<br>
                        â€¢ Local variables<br>
                        â€¢ Return addresses<br>
                        â€¢ Grows downward during execution
                    </div>
                </div>
            </div>
            
            <!-- Section 2: Process Control Block -->
            <div class="section">
                <div class="section-title">2. Process Control Block (PCB)</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>Process Control Block (PCB):</strong><br>
                        A data structure maintained by OS for every process. Contains all information about the process. Also called Task Control Block (TCB).
                    </div>
                    
                    <div class="example-box">
                        <strong>Think of PCB as:</strong><br>
                        Student's report card containing all information: name, roll number, marks, attendance, behavior notes.<br><br>
                        Similarly, PCB contains everything about a process!
                    </div>
                    
                    <div class="subsection-title">Information in PCB:</div>
                    <div class="code-box"><strong>PCB Structure:</strong>

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Process ID (PID): 1234      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Process State: Running      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Program Counter: 0x4A3B     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ CPU Registers: AX, BX, CX...â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Priority: 5                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Memory Limits: 0x1000-0x5000â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ List of Open Files: file1.txtâ”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Accounting Info: CPU time   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</div>
                    
                    <div class="step-box">
                        <strong>1. Process ID (PID):</strong><br>
                        Unique number identifying the process<br>
                        Example: Chrome PID = 1234<br><br>
                        
                        <strong>2. Process State:</strong><br>
                        Current state (New, Ready, Running, Waiting, Terminated)<br><br>
                        
                        <strong>3. Program Counter:</strong><br>
                        Address of next instruction to execute<br><br>
                        
                        <strong>4. CPU Registers:</strong><br>
                        Values of all CPU registers (saved during context switch)<br><br>
                        
                        <strong>5. CPU Scheduling Information:</strong><br>
                        â€¢ Priority<br>
                        â€¢ Scheduling queue pointers<br><br>
                        
                        <strong>6. Memory Management Information:</strong><br>
                        â€¢ Base and limit registers<br>
                        â€¢ Page tables<br><br>
                        
                        <strong>7. Accounting Information:</strong><br>
                        â€¢ CPU time used<br>
                        â€¢ Time limits<br>
                        â€¢ Process start time<br><br>
                        
                        <strong>8. I/O Status Information:</strong><br>
                        â€¢ List of open files<br>
                        â€¢ I/O devices allocated
                    </div>
                    
                    <div class="note-box">
                        <strong>Why PCB is Important:</strong><br>
                        When OS switches from one process to another (context switch), it saves current process state in PCB and loads next process state from its PCB. Without PCB, OS wouldn't know where to resume execution!
                    </div>
                </div>
            </div>
            
            <!-- Section 3: Process States -->
            <div class="section">
                <div class="section-title">3. Process States</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>Process States:</strong><br>
                        A process changes state during its execution. There are 5 main states a process can be in.
                    </div>
                    
                    <div class="code-box"><strong>Process State Diagram:</strong>

        â”Œâ”€â”€â”€â”€â”€â”€â”€â”
        â”‚  NEW  â”‚  Process created
        â””â”€â”€â”€â”¬â”€â”€â”€â”˜
            â”‚ admitted
            â†“
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  scheduler dispatch  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ READY  â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’  â”‚ RUNNING â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜                       â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
            â†‘                                 â”‚
            â”‚ I/O or event completion         â”‚ interrupt
            â”‚                                 â†“
            â”‚                            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ READY  â”‚
                                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                              â”‚
                                              â”‚ I/O or event wait
                                              â†“
                                         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                         â”‚ WAITING â”‚
                                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                              â”‚
                                              â”‚ exit
                                              â†“
                                         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                         â”‚ TERMINATED â”‚
                                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</div>
                    
                    <div class="subsection-title">1. New State:</div>
                    <div class="example-box">
                        <strong>New:</strong> Process is being created<br>
                        â€¢ OS is allocating resources<br>
                        â€¢ PCB is being initialized<br>
                        â€¢ Not yet admitted to ready queue<br><br>
                        
                        <strong>Example:</strong> You double-click Chrome icon â†’ Process in New state
                    </div>
                    
                    <div class="subsection-title">2. Ready State:</div>
                    <div class="example-box">
                        <strong>Ready:</strong> Process is ready to execute, waiting for CPU<br>
                        â€¢ All resources allocated except CPU<br>
                        â€¢ In ready queue<br>
                        â€¢ Waiting for scheduler to assign CPU<br><br>
                        
                        <strong>Example:</strong> Multiple students ready to ask teacher a question, waiting for their turn
                    </div>
                    
                    <div class="subsection-title">3. Running State:</div>
                    <div class="example-box">
                        <strong>Running:</strong> Process is currently executing on CPU<br>
                        â€¢ Instructions being executed<br>
                        â€¢ Only ONE process can run on one CPU at a time<br><br>
                        
                        <strong>Example:</strong> Student currently asking teacher question
                    </div>
                    
                    <div class="subsection-title">4. Waiting State (Blocked):</div>
                    <div class="example-box">
                        <strong>Waiting:</strong> Process waiting for some event (I/O completion)<br>
                        â€¢ Cannot execute even if CPU is free<br>
                        â€¢ Waiting for I/O operation to complete<br>
                        â€¢ Or waiting for a signal/event<br><br>
                        
                        <strong>Example:</strong> Process waiting for user to click button, or waiting for file to load from disk
                    </div>
                    
                    <div class="subsection-title">5. Terminated State:</div>
                    <div class="example-box">
                        <strong>Terminated:</strong> Process has finished execution<br>
                        â€¢ All resources released<br>
                        â€¢ PCB being deleted<br>
                        â€¢ Process removed from system<br><br>
                        
                        <strong>Example:</strong> You close Chrome â†’ Process terminates
                    </div>
                </div>
            </div>
            
            <!-- Section 4: Process State Transitions -->
            <div class="section">
                <div class="section-title">4. Process State Transitions</div>
                <div class="content">
                    <div class="subsection-title">State Transitions Explained:</div>
                    
                    <div class="step-box">
                        <strong>1. New â†’ Ready (Admitted):</strong><br>
                        OS admits process to ready queue<br>
                        Example: OS decides there's enough memory for new process<br><br>
                        
                        <strong>2. Ready â†’ Running (Scheduler Dispatch):</strong><br>
                        CPU scheduler selects process from ready queue<br>
                        Example: Your process gets CPU time<br><br>
                        
                        <strong>3. Running â†’ Ready (Interrupt):</strong><br>
                        Process loses CPU (time slice expired or higher priority process arrives)<br>
                        Example: Timer interrupt - your time is up!<br><br>
                        
                        <strong>4. Running â†’ Waiting (I/O or Event Wait):</strong><br>
                        Process needs I/O operation<br>
                        Example: Process reading from disk - must wait for disk<br><br>
                        
                        <strong>5. Waiting â†’ Ready (I/O Completion):</strong><br>
                        I/O operation completed, process can run again<br>
                        Example: File loaded from disk, process ready to continue<br><br>
                        
                        <strong>6. Running â†’ Terminated (Exit):</strong><br>
                        Process completes execution or is killed<br>
                        Example: Program finishes or crashes
                    </div>
                    
                    <div class="example-box">
                        <strong>Real-life Example - Downloading a File:</strong><br><br>
                        
                        1. <strong>New:</strong> You click download button â†’ Process created<br>
                        2. <strong>Ready:</strong> Process ready to start download<br>
                        3. <strong>Running:</strong> Process starts downloading<br>
                        4. <strong>Waiting:</strong> Waiting for network packets to arrive<br>
                        5. <strong>Ready:</strong> Data received, ready to save to disk<br>
                        6. <strong>Running:</strong> Writing data to disk<br>
                        7. <strong>Terminated:</strong> Download complete!
                    </div>
                </div>
            </div>
            
            <!-- Section 5: Process Scheduling -->
            <div class="section">
                <div class="section-title">5. Process Scheduling</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>Process Scheduling:</strong><br>
                        The method by which OS decides which process runs on CPU and for how long. Goal is to maximize CPU utilization and provide fair execution time to all processes.
                    </div>
                    
                    <div class="subsection-title">Scheduling Queues:</div>
                    <div class="code-box"><strong>Types of Queues:</strong>

1. Job Queue:
   All processes in the system
   
2. Ready Queue:
   Processes in main memory, ready to execute
   Waiting for CPU
   
3. Device Queue:
   Processes waiting for I/O device
   Each device has its own queue
   
Example:
Ready Queue: [P1, P3, P5]  â† Waiting for CPU
Disk Queue:  [P2, P4]      â† Waiting for disk
Printer Queue: [P6]        â† Waiting for printer</div>
                    
                    <div class="subsection-title">Types of Schedulers:</div>
                    
                    <div class="step-box">
                        <strong>1. Long-Term Scheduler (Job Scheduler):</strong><br>
                        â€¢ Selects which processes to bring into ready queue<br>
                        â€¢ Controls degree of multiprogramming<br>
                        â€¢ Executes less frequently (minutes)<br>
                        â€¢ Decides: New â†’ Ready<br><br>
                        
                        <strong>Example:</strong> Decides whether to load new program into memory or not
                    </div>
                    
                    <div class="step-box">
                        <strong>2. Short-Term Scheduler (CPU Scheduler):</strong><br>
                        â€¢ Selects which process from ready queue gets CPU<br>
                        â€¢ Executes very frequently (milliseconds)<br>
                        â€¢ Must be very fast!<br>
                        â€¢ Decides: Ready â†’ Running<br><br>
                        
                        <strong>Example:</strong> Every 10ms, decides which process runs next
                    </div>
                    
                    <div class="step-box">
                        <strong>3. Medium-Term Scheduler:</strong><br>
                        â€¢ Swaps processes in/out of memory<br>
                        â€¢ Reduces degree of multiprogramming<br>
                        â€¢ Used in swapping<br><br>
                        
                        <strong>Example:</strong> Moves inactive process from RAM to disk to free memory
                    </div>
                    
                    <div class="subsection-title">Context Switch:</div>
                    <div class="definition-box">
                        <strong>Context Switch:</strong><br>
                        The process of saving state of current process and loading state of next process.
                    </div>
                    
                    <div class="code-box"><strong>Context Switch Steps:</strong>

1. Save state of Process A in its PCB
   - Program counter
   - CPU registers
   - Memory maps
   
2. Load state of Process B from its PCB
   - Restore program counter
   - Restore CPU registers
   - Restore memory maps
   
3. Process B starts running

<strong>Time:</strong> Context switch is pure overhead
No useful work done during switch
Typically takes 1-10 microseconds</div>
                    
                    <div class="note-box">
                        <strong>Important:</strong> Context switching is expensive! That's why OS tries to minimize it. Too many context switches = system becomes slow.
                    </div>
                </div>
            </div>
            
            <div class="divider"></div>
            
            <!-- Section 6: Threads -->
            <div class="section">
                <div class="section-title">6. Threads</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>Thread:</strong><br>
                        A thread is a lightweight process - the smallest unit of execution within a process. Multiple threads can exist within a single process, sharing the same resources but executing independently.
                    </div>
                    
                    <div class="example-box">
                        <strong>Real-life Analogy - Microsoft Word:</strong><br><br>
                        
                        <strong>Single Process (Word):</strong><br>
                        â€¢ Main process = Word application<br><br>
                        
                        <strong>Multiple Threads within Word:</strong><br>
                        â€¢ Thread 1: Accept your typing<br>
                        â€¢ Thread 2: Check spelling (red underlines)<br>
                        â€¢ Thread 3: Auto-save document<br>
                        â€¢ Thread 4: Display UI<br><br>
                        
                        All happening simultaneously within one Word process!
                    </div>
                    
                    <div class="subsection-title">Process vs Thread:</div>
                    <div class="code-box"><strong>Comparison:</strong>

Aspect          | Process              | Thread
--------------- | -------------------- | --------------------
Definition      | Heavy-weight         | Light-weight
Resources       | Own memory space     | Share process memory
Creation time   | Slow                 | Fast
Context switch  | Expensive            | Cheap
Communication   | IPC needed           | Direct (shared memory)
Isolation       | Isolated             | Not isolated
Example         | Chrome (entire app)  | One tab in Chrome

<strong>Memory Layout:</strong>

Process A                    Process B
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Thread 1     â”‚            â”‚ Thread 1     â”‚
â”‚ Thread 2     â”‚            â”‚              â”‚
â”‚ Thread 3     â”‚            â”‚              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤            â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Shared:      â”‚            â”‚ Shared:      â”‚
â”‚ - Code       â”‚            â”‚ - Code       â”‚
â”‚ - Data       â”‚            â”‚ - Data       â”‚
â”‚ - Heap       â”‚            â”‚ - Heap       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Each thread has:            Each thread has:
- Own stack                 - Own stack
- Own registers             - Own registers
- Own program counter       - Own program counter</div>
                    
                    <div class="subsection-title">Benefits of Threads:</div>
                    <div class="advantage-box">
                        <strong>1. Responsiveness:</strong><br>
                        Application remains responsive even if part is blocked<br>
                        Example: Web browser can download file while you browse other tabs<br><br>
                        
                        <strong>2. Resource Sharing:</strong><br>
                        Threads share memory and resources of process<br>
                        No need for IPC mechanisms<br>
                        Easier communication between threads<br><br>
                        
                        <strong>3. Economy:</strong><br>
                        Creating thread is cheaper than creating process<br>
                        Context switch between threads is faster<br>
                        Example: Thread creation 10-100x faster than process<br><br>
                        
                        <strong>4. Scalability (Multicore):</strong><br>
                        Threads can run on different CPU cores simultaneously<br>
                        True parallelism on multicore systems<br>
                        Example: Video encoding - each thread processes different frame
                    </div>
                    
                    <div class="subsection-title">Types of Threads:</div>
                    
                    <div class="step-box">
                        <strong>1. User-Level Threads (ULT):</strong><br>
                        Managed by user-level thread library, OS doesn't know about them<br><br>
                        
                        <strong>How it works:</strong><br>
                        â€¢ Thread library in user space manages threads<br>
                        â€¢ OS sees only one process<br>
                        â€¢ Thread switching done by library (no kernel involvement)<br><br>
                        
                        <strong>Advantages:</strong><br>
                        âœ“ Fast thread creation and switching<br>
                        âœ“ Can run on any OS<br>
                        âœ“ Flexible scheduling<br><br>
                        
                        <strong>Disadvantages:</strong><br>
                        âœ— If one thread blocks, entire process blocks<br>
                        âœ— Cannot use multiple CPUs (OS thinks it's one process)<br><br>
                        
                        <strong>Example:</strong> Java Green Threads (old)
                    </div>
                    
                    <div class="step-box">
                        <strong>2. Kernel-Level Threads (KLT):</strong><br>
                        Managed directly by OS kernel<br><br>
                        
                        <strong>How it works:</strong><br>
                        â€¢ OS knows about each thread<br>
                        â€¢ Kernel schedules threads<br>
                        â€¢ OS maintains thread table<br><br>
                        
                        <strong>Advantages:</strong><br>
                        âœ“ If one thread blocks, others can continue<br>
                        âœ“ Can use multiple CPUs (true parallelism)<br>
                        âœ“ Better for multicore systems<br><br>
                        
                        <strong>Disadvantages:</strong><br>
                        âœ— Slower (kernel mode switches required)<br>
                        âœ— More overhead<br><br>
                        
                        <strong>Example:</strong> Windows threads, Linux threads
                    </div>
                    
                    <div class="subsection-title">Multithreading Models:</div>
                    
                    <div class="example-box">
                        <strong>1. Many-to-One Model:</strong><br>
                        Many user threads â†’ mapped to â†’ One kernel thread<br><br>
                        
                        <strong>Diagram:</strong><br>
                        User Level: [T1] [T2] [T3] [T4]<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â†“<br>
                        Kernel Level: &nbsp;&nbsp;&nbsp;&nbsp;[K1]<br><br>
                        
                        <strong>Characteristics:</strong><br>
                        â€¢ If one thread blocks, all block<br>
                        â€¢ Cannot run on multiple CPUs<br>
                        â€¢ Fast thread management<br><br>
                        
                        <strong>Example:</strong> Green Threads
                    </div>
                    
                    <div class="example-box">
                        <strong>2. One-to-One Model:</strong><br>
                        One user thread â†’ mapped to â†’ One kernel thread<br><br>
                        
                        <strong>Diagram:</strong><br>
                        User Level: [T1] [T2] [T3] [T4]<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â†“&nbsp;&nbsp;&nbsp;&nbsp;â†“&nbsp;&nbsp;&nbsp;&nbsp;â†“&nbsp;&nbsp;&nbsp;&nbsp;â†“<br>
                        Kernel Level: [K1] [K2] [K3] [K4]<br><br>
                        
                        <strong>Characteristics:</strong><br>
                        â€¢ If one thread blocks, others continue<br>
                        â€¢ Can use multiple CPUs<br>
                        â€¢ Creating thread = creating kernel thread (overhead)<br>
                        â€¢ Most systems limit number of threads<br><br>
                        
                        <strong>Example:</strong> Windows, Linux
                    </div>
                    
                    <div class="example-box">
                        <strong>3. Many-to-Many Model:</strong><br>
                        Many user threads â†’ mapped to â†’ Many kernel threads<br><br>
                        
                        <strong>Diagram:</strong><br>
                        User Level: [T1] [T2] [T3] [T4] [T5] [T6]<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â†“&nbsp;&nbsp;&nbsp;&nbsp;â†“&nbsp;&nbsp;&nbsp;&nbsp;â†“<br>
                        Kernel Level: &nbsp;&nbsp;&nbsp;&nbsp;[K1] [K2] [K3]<br><br>
                        
                        <strong>Characteristics:</strong><br>
                        â€¢ OS creates sufficient kernel threads<br>
                        â€¢ Best of both worlds<br>
                        â€¢ Can run on multiple CPUs<br>
                        â€¢ If one blocks, others continue<br><br>
                        
                        <strong>Example:</strong> Solaris, older UNIX versions
                    </div>
                </div>
            </div>
            
            <!-- Section 7: CPU Scheduling -->
            <div class="section">
                <div class="section-title">7. CPU Scheduling</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>CPU Scheduling:</strong><br>
                        The process of deciding which process in the ready queue gets the CPU next. Goal is to keep CPU busy and provide fair execution time to all processes.
                    </div>
                    
                    <div class="example-box">
                        <strong>Why Scheduling Needed?</strong><br>
                        In multiprogramming, when one process waits (for I/O), CPU switches to another process. Scheduling decides which process runs next to maximize CPU utilization.
                    </div>
                    
                    <div class="subsection-title">Preemptive vs Non-Preemptive Scheduling:</div>
                    
                    <div class="step-box">
                        <strong>Non-Preemptive Scheduling:</strong><br>
                        Once CPU is allocated to a process, process keeps it until it terminates or switches to waiting state. CPU cannot be taken away forcefully.<br><br>
                        
                        <strong>Characteristics:</strong><br>
                        â€¢ Process runs until completion or blocks<br>
                        â€¢ No interruption by scheduler<br>
                        â€¢ Simple to implement<br><br>
                        
                        <strong>Real-life Example:</strong><br>
                        Doctor's appointment - Once doctor starts with patient, continues until done. Next patient must wait.<br><br>
                        
                        <strong>Advantages:</strong><br>
                        âœ“ Simple<br>
                        âœ“ Low overhead (no context switching)<br>
                        âœ“ Predictable<br><br>
                        
                        <strong>Disadvantages:</strong><br>
                        âœ— Long process blocks CPU for long time<br>
                        âœ— Poor response time<br>
                        âœ— Not suitable for time-sharing systems<br><br>
                        
                        <strong>Examples:</strong> FCFS, SJF (non-preemptive), Priority (non-preemptive)
                    </div>
                    
                    <div class="step-box">
                        <strong>Preemptive Scheduling:</strong><br>
                        CPU can be taken away from a running process before it completes. Scheduler can interrupt and switch to another process.<br><br>
                        
                        <strong>Characteristics:</strong><br>
                        â€¢ Process can be interrupted<br>
                        â€¢ Higher priority process can take CPU<br>
                        â€¢ Timer interrupts used<br><br>
                        
                        <strong>Real-life Example:</strong><br>
                        Emergency room - If critical patient arrives, doctor stops current patient and attends emergency first.<br><br>
                        
                        <strong>Advantages:</strong><br>
                        âœ“ Better response time<br>
                        âœ“ Fair to all processes<br>
                        âœ“ Suitable for time-sharing<br>
                        âœ“ High priority tasks handled quickly<br><br>
                        
                        <strong>Disadvantages:</strong><br>
                        âœ— Complex<br>
                        âœ— Context switch overhead<br>
                        âœ— Risk of race conditions<br><br>
                        
                        <strong>Examples:</strong> Round Robin, SRTF, Priority (preemptive)
                    </div>
                    
                    <div class="code-box"><strong>Comparison:</strong>

Aspect          | Non-Preemptive       | Preemptive
--------------- | -------------------- | --------------------
CPU Release     | Voluntary            | Forced
Interruption    | No                   | Yes
Response Time   | Poor                 | Good
Overhead        | Low                  | High
Complexity      | Simple               | Complex
Fairness        | Less fair            | More fair
Use Case        | Batch systems        | Time-sharing systems</div>
                </div>
            </div>
            
            <!-- Section 8: Scheduling Criteria -->
            <div class="section">
                <div class="section-title">8. Scheduling Criteria</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>Scheduling Criteria:</strong><br>
                        Metrics used to evaluate and compare different CPU scheduling algorithms. Help determine which algorithm is best for a given situation.
                    </div>
                    
                    <div class="subsection-title">Key Criteria:</div>
                    
                    <div class="step-box">
                        <strong>1. CPU Utilization:</strong><br>
                        Percentage of time CPU is busy (not idle)<br><br>
                        
                        <strong>Goal:</strong> Maximize (keep CPU as busy as possible)<br>
                        <strong>Range:</strong> 0% to 100%<br>
                        <strong>Good:</strong> 40% (lightly loaded) to 90% (heavily loaded)<br><br>
                        
                        <strong>Formula:</strong><br>
                        CPU Utilization = (Total Busy Time / Total Time) Ã— 100%<br><br>
                        
                        <strong>Example:</strong><br>
                        If CPU is busy for 80 seconds out of 100 seconds â†’ 80% utilization
                    </div>
                    
                    <div class="step-box">
                        <strong>2. Throughput:</strong><br>
                        Number of processes completed per unit time<br><br>
                        
                        <strong>Goal:</strong> Maximize (complete more processes)<br>
                        <strong>Unit:</strong> processes/hour or processes/second<br><br>
                        
                        <strong>Formula:</strong><br>
                        Throughput = Number of processes completed / Total time<br><br>
                        
                        <strong>Example:</strong><br>
                        10 processes completed in 100 seconds â†’ Throughput = 0.1 processes/second
                    </div>
                    
                    <div class="step-box">
                        <strong>3. Turnaround Time:</strong><br>
                        Total time from process submission to completion<br>
                        Time interval from arrival to termination<br><br>
                        
                        <strong>Goal:</strong> Minimize<br><br>
                        
                        <strong>Formula:</strong><br>
                        Turnaround Time = Completion Time - Arrival Time<br>
                        Or<br>
                        Turnaround Time = Waiting Time + Burst Time<br><br>
                        
                        <strong>Example:</strong><br>
                        Process arrives at time 0, completes at time 10<br>
                        â†’ Turnaround Time = 10 - 0 = 10 seconds
                    </div>
                    
                    <div class="step-box">
                        <strong>4. Waiting Time:</strong><br>
                        Total time process spends in ready queue waiting for CPU<br>
                        Does NOT include execution time<br><br>
                        
                        <strong>Goal:</strong> Minimize<br><br>
                        
                        <strong>Formula:</strong><br>
                        Waiting Time = Turnaround Time - Burst Time<br><br>
                        
                        <strong>Example:</strong><br>
                        Turnaround Time = 10s, Burst Time = 3s<br>
                        â†’ Waiting Time = 10 - 3 = 7 seconds
                    </div>
                    
                    <div class="step-box">
                        <strong>5. Response Time:</strong><br>
                        Time from process submission to first response (first time it gets CPU)<br>
                        Important for interactive systems<br><br>
                        
                        <strong>Goal:</strong> Minimize<br><br>
                        
                        <strong>Formula:</strong><br>
                        Response Time = Time of first response - Arrival Time<br><br>
                        
                        <strong>Example:</strong><br>
                        Process arrives at 0, first gets CPU at time 5<br>
                        â†’ Response Time = 5 - 0 = 5 seconds<br><br>
                        
                        <strong>Difference from Waiting Time:</strong><br>
                        Response time is till FIRST response, waiting time is TOTAL waiting
                    </div>
                    
                    <div class="code-box"><strong>Summary of Criteria:</strong>

Criteria         | What it measures           | Goal
---------------- | -------------------------- | --------
CPU Utilization  | % time CPU is busy         | Maximize
Throughput       | Processes completed/time   | Maximize
Turnaround Time  | Submission to completion   | Minimize
Waiting Time     | Time in ready queue        | Minimize
Response Time    | Till first response        | Minimize</div>
                    
                    <div class="note-box">
                        <strong>Important:</strong><br>
                        No single algorithm is best for all criteria. Trade-offs exist:<br>
                        â€¢ Algorithm good for throughput may have poor response time<br>
                        â€¢ Algorithm minimizing waiting time may reduce CPU utilization<br>
                        â€¢ Choice depends on system requirements (batch vs interactive)
                    </div>
                </div>
            </div>
            
            <div class="divider"></div>
            
            <!-- Section 9: Scheduling Algorithms -->
            <div class="section">
                <div class="section-title">9. CPU Scheduling Algorithms</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>Scheduling Algorithms:</strong><br>
                        Rules/methods used by CPU scheduler to decide which process from the ready queue gets the CPU next.
                    </div>
                    
                    <div class="subsection-title">1. First Come First Serve (FCFS):</div>
                    <div class="definition-box">
                        <strong>FCFS:</strong> Simplest algorithm. Process that arrives first gets CPU first. Non-preemptive.
                    </div>
                    
                    <div class="example-box">
                        <strong>Real-life Example:</strong> Queue at ticket counter - First person in line gets served first!<br><br>
                        
                        <strong>Implementation:</strong> Using FIFO queue<br>
                        â€¢ New process added to tail of queue<br>
                        â€¢ Scheduler picks from head of queue
                    </div>
                    
                    <div class="code-box"><strong>Example:</strong>

Process | Arrival Time | Burst Time
------- | ------------ | ----------
P1      | 0            | 24
P2      | 1            | 3
P3      | 2            | 3

<strong>Gantt Chart:</strong>
|  P1  |  P2  |  P3  |
0     24    27    30

<strong>Calculations:</strong>
P1: Waiting Time = 0,  Turnaround = 24
P2: Waiting Time = 23, Turnaround = 26
P3: Waiting Time = 25, Turnaround = 28

Average Waiting Time = (0+23+25)/3 = 16 ms
Average Turnaround = (24+26+28)/3 = 26 ms</div>
                    
                    <div class="advantage-box">
                        <strong>Advantages:</strong><br>
                        âœ“ Simple and easy to implement<br>
                        âœ“ Fair (first come, first served)<br>
                        âœ“ No starvation
                    </div>
                    
                    <div class="threat-box">
                        <strong>Disadvantages:</strong><br>
                        âœ— Convoy Effect (short processes wait for long process)<br>
                        âœ— Poor average waiting time<br>
                        âœ— Not suitable for time-sharing systems<br>
                        âœ— Non-preemptive (cannot interrupt)
                    </div>
                    
                    <div class="note-box">
                        <strong>Convoy Effect:</strong> When short processes wait for a long process to complete. Like being stuck behind a slow truck on highway - all fast cars must wait!
                    </div>
                    
                    <div class="subsection-title">2. Shortest Job First (SJF):</div>
                    <div class="definition-box">
                        <strong>SJF:</strong> Process with smallest burst time gets CPU first. Can be preemptive or non-preemptive. Optimal algorithm (gives minimum average waiting time).
                    </div>
                    
                    <div class="code-box"><strong>Non-Preemptive SJF Example:</strong>

Process | Arrival Time | Burst Time
------- | ------------ | ----------
P1      | 0            | 7
P2      | 2            | 4
P3      | 4            | 1
P4      | 5            | 4

<strong>Execution Order:</strong> P1 â†’ P3 â†’ P2 â†’ P4
(P1 starts first, then pick shortest)

<strong>Gantt Chart:</strong>
|  P1  | P3 |  P2  |  P4  |
0     7    8     12    16

<strong>Calculations:</strong>
P1: Waiting = 0,  Turnaround = 7
P3: Waiting = 3,  Turnaround = 4
P2: Waiting = 6,  Turnaround = 10
P4: Waiting = 7,  Turnaround = 11

Average Waiting Time = (0+6+3+7)/4 = 4 ms</div>
                    
                    <div class="advantage-box">
                        <strong>Advantages:</strong><br>
                        âœ“ Minimum average waiting time<br>
                        âœ“ Optimal algorithm<br>
                        âœ“ Better throughput than FCFS
                    </div>
                    
                    <div class="threat-box">
                        <strong>Disadvantages:</strong><br>
                        âœ— Starvation (long processes may never execute)<br>
                        âœ— Cannot know exact burst time in advance<br>
                        âœ— Requires prediction of burst time
                    </div>
                    
                    <div class="subsection-title">3. Shortest Remaining Time First (SRTF):</div>
                    <div class="definition-box">
                        <strong>SRTF:</strong> Preemptive version of SJF. If new process arrives with shorter remaining time than current process, CPU switches to new process.
                    </div>
                    
                    <div class="code-box"><strong>Preemptive SJF (SRTF) Example:</strong>

Process | Arrival Time | Burst Time
------- | ------------ | ----------
P1      | 0            | 8
P2      | 1            | 4
P3      | 2            | 9
P4      | 3            | 5

<strong>Time 0:</strong> P1 starts (only process)
<strong>Time 1:</strong> P2 arrives (BT=4 < remaining P1=7) â†’ Switch to P2
<strong>Time 2:</strong> P3 arrives (BT=9 > remaining P2=3) â†’ Continue P2
<strong>Time 3:</strong> P4 arrives (BT=5 > remaining P2=2) â†’ Continue P2
<strong>Time 5:</strong> P2 done, P4 shortest (BT=5) â†’ P4 runs
<strong>Time 10:</strong> P4 done, P1 remaining (BT=7) â†’ P1 runs
<strong>Time 17:</strong> P1 done, P3 runs

<strong>Gantt Chart:</strong>
| P1 | P2  | P4  | P1  | P3     |
0   1    5    10   17   26

<strong>Average Waiting Time:</strong> Better than non-preemptive SJF</div>
                    
                    <div class="subsection-title">4. Priority Scheduling:</div>
                    <div class="definition-box">
                        <strong>Priority Scheduling:</strong> Each process has a priority. CPU allocated to process with highest priority. Can be preemptive or non-preemptive.
                    </div>
                    
                    <div class="example-box">
                        <strong>Priority Values:</strong><br>
                        â€¢ Lower number = Higher priority (usually)<br>
                        â€¢ Example: Priority 1 > Priority 5<br><br>
                        
                        <strong>Real-life Example:</strong> Emergency room - Critical patients (high priority) treated before minor injuries (low priority)
                    </div>
                    
                    <div class="code-box"><strong>Non-Preemptive Priority Example:</strong>

Process | Arrival | Burst | Priority
------- | ------- | ----- | --------
P1      | 0       | 10    | 3
P2      | 1       | 1     | 1 (Highest)
P3      | 2       | 2     | 4
P4      | 3       | 1     | 5
P5      | 4       | 5     | 2

<strong>Execution Order:</strong> P1 â†’ P2 â†’ P5 â†’ P3 â†’ P4
(P1 starts, then by priority)

<strong>Gantt Chart:</strong>
| P1  | P2 | P5  | P3 | P4 |
0    10   11   16   18  19</div>
                    
                    <div class="threat-box">
                        <strong>Major Problem - Starvation:</strong><br>
                        Low priority processes may never execute if high priority processes keep arriving.<br><br>
                        
                        <strong>Solution - Aging:</strong><br>
                        Gradually increase priority of waiting processes over time.<br>
                        Example: Every 10 minutes waiting â†’ increase priority by 1
                    </div>
                    
                    <div class="subsection-title">5. Round Robin (RR):</div>
                    <div class="definition-box">
                        <strong>Round Robin:</strong> Each process gets small unit of CPU time (time quantum), then moved to end of queue. Preemptive. Designed for time-sharing systems.
                    </div>
                    
                    <div class="example-box">
                        <strong>Real-life Example:</strong> Teacher giving each student 5 minutes to ask questions. After 5 minutes, next student gets turn. First student goes to back of line if more questions.<br><br>
                        
                        <strong>Time Quantum (q):</strong> Fixed time slice (typically 10-100 milliseconds)
                    </div>
                    
                    <div class="code-box"><strong>Round Robin Example (Time Quantum = 4):</strong>

Process | Arrival Time | Burst Time
------- | ------------ | ----------
P1      | 0            | 24
P2      | 0            | 3
P3      | 0            | 3

<strong>Execution:</strong>
Time 0-4:   P1 runs (remaining = 20)
Time 4-7:   P2 runs (remaining = 0, done!)
Time 7-10:  P3 runs (remaining = 0, done!)
Time 10-14: P1 runs (remaining = 16)
Time 14-18: P1 runs (remaining = 12)
Time 18-22: P1 runs (remaining = 8)
Time 22-26: P1 runs (remaining = 4)
Time 26-30: P1 runs (remaining = 0, done!)

<strong>Gantt Chart:</strong>
| P1 | P2 | P3 | P1 | P1 | P1 | P1 | P1 |
0   4    7   10  14  18  22  26  30

<strong>Calculations:</strong>
P1: Waiting = 6,  Turnaround = 30
P2: Waiting = 4,  Turnaround = 7
P3: Waiting = 7,  Turnaround = 10

Average Waiting Time = (6+4+7)/3 = 5.67 ms</div>
                    
                    <div class="advantage-box">
                        <strong>Advantages:</strong><br>
                        âœ“ Fair to all processes<br>
                        âœ“ No starvation<br>
                        âœ“ Good response time<br>
                        âœ“ Suitable for time-sharing systems
                    </div>
                    
                    <div class="threat-box">
                        <strong>Disadvantages:</strong><br>
                        âœ— Context switch overhead<br>
                        âœ— Performance depends on time quantum<br>
                        âœ— Average waiting time often high
                    </div>
                    
                    <div class="note-box">
                        <strong>Choosing Time Quantum:</strong><br>
                        â€¢ <strong>Too large:</strong> Becomes like FCFS (poor response)<br>
                        â€¢ <strong>Too small:</strong> Too many context switches (overhead)<br>
                        â€¢ <strong>Rule of thumb:</strong> 80% of processes should complete within one quantum
                    </div>
                    
                    <div class="subsection-title">6. Multilevel Queue Scheduling:</div>
                    <div class="definition-box">
                        <strong>Multilevel Queue:</strong> Ready queue divided into multiple queues based on process characteristics. Each queue has its own scheduling algorithm.
                    </div>
                    
                    <div class="code-box"><strong>Multilevel Queue Structure:</strong>

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ System Processes (Q1)    â”‚ â† Highest Priority
â”‚ Algorithm: FCFS          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Interactive (Q2)         â”‚
â”‚ Algorithm: Round Robin   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Batch Processes (Q3)     â”‚ â† Lowest Priority
â”‚ Algorithm: FCFS          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

<strong>Rules:</strong>
â€¢ Process permanently assigned to one queue
â€¢ Queue Q1 has priority over Q2, Q2 over Q3
â€¢ Q2 runs only if Q1 is empty
â€¢ Q3 runs only if Q1 and Q2 are empty</div>
                    
                    <div class="example-box">
                        <strong>Example Categories:</strong><br>
                        â€¢ <strong>Foreground (Interactive):</strong> User applications (high priority, RR)<br>
                        â€¢ <strong>Background (Batch):</strong> Compilations, backups (low priority, FCFS)
                    </div>
                    
                    <div class="advantage-box">
                        <strong>Advantages:</strong><br>
                        âœ“ Different algorithms for different process types<br>
                        âœ“ Low overhead (no queue switching)<br>
                        âœ“ Priority-based execution
                    </div>
                    
                    <div class="threat-box">
                        <strong>Disadvantages:</strong><br>
                        âœ— Starvation (low priority queues may starve)<br>
                        âœ— Inflexible (process cannot move between queues)
                    </div>
                </div>
            </div>
            
            <!-- Comparison Table -->
            <div class="section">
                <div class="section-title">10. Scheduling Algorithms Comparison</div>
                <div class="content">
                    <div class="code-box"><strong>Complete Comparison:</strong>

Algorithm    | Preemptive | Avg WT  | Starvation | Overhead
------------ | ---------- | ------- | ---------- | --------
FCFS         | No         | High    | No         | Low
SJF          | No         | Minimum | Yes        | Low
SRTF         | Yes        | Low     | Yes        | Medium
Priority     | Both       | Medium  | Yes        | Medium
Round Robin  | Yes        | High    | No         | High
Multilevel Q | Yes        | Medium  | Yes        | Low

<strong>Best Use Cases:</strong>

FCFS        â†’ Batch systems, simple scenarios
SJF/SRTF    â†’ When burst time known, minimize WT
Priority    â†’ Real-time systems, critical tasks
Round Robin â†’ Time-sharing, interactive systems
Multilevel  â†’ Systems with different process types</div>
                    
                    <div class="note-box">
                        <strong>Key Takeaways:</strong><br>
                        â€¢ <strong>FCFS:</strong> Simplest but convoy effect<br>
                        â€¢ <strong>SJF:</strong> Optimal but starvation possible<br>
                        â€¢ <strong>SRTF:</strong> Better than SJF but more overhead<br>
                        â€¢ <strong>Priority:</strong> Flexible but needs aging for starvation<br>
                        â€¢ <strong>Round Robin:</strong> Fair but context switch overhead<br>
                        â€¢ <strong>Multilevel:</strong> Realistic but complex<br><br>
                        
                        <strong>No algorithm is perfect!</strong> Choice depends on system requirements.
                    </div>
                </div>
            </div>
            
            <div class="divider"></div>
            
            <!-- Section 11: Inter-process Communication -->
            <div class="section">
                <div class="section-title">11. Inter-process Communication (IPC)</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>Inter-process Communication (IPC):</strong><br>
                        Mechanism that allows processes to communicate and synchronize their actions. Processes need to exchange data and coordinate execution.
                    </div>
                    
                    <div class="example-box">
                        <strong>Why IPC Needed?</strong><br>
                        â€¢ Share information between processes<br>
                        â€¢ Speed up computation (divide work among processes)<br>
                        â€¢ Modularity (separate concerns)<br>
                        â€¢ Convenience (user may run multiple tasks)<br><br>
                        
                        <strong>Example:</strong> Web browser - one process downloads, another displays, another handles user input
                    </div>
                    
                    <div class="subsection-title">Two Models of IPC:</div>
                    
                    <div class="step-box">
                        <strong>1. Shared Memory:</strong><br>
                        Processes share a common memory region for communication<br><br>
                        
                        <strong>How it works:</strong><br>
                        â€¢ OS creates shared memory segment<br>
                        â€¢ Processes read/write to this shared region<br>
                        â€¢ Fast (no kernel involvement after setup)<br><br>
                        
                        <strong>Advantages:</strong><br>
                        âœ“ Fast (direct memory access)<br>
                        âœ“ Efficient for large data transfer<br><br>
                        
                        <strong>Disadvantages:</strong><br>
                        âœ— Need synchronization (to avoid conflicts)<br>
                        âœ— Complex to implement
                    </div>
                    
                    <div class="step-box">
                        <strong>2. Message Passing:</strong><br>
                        Processes communicate by sending/receiving messages<br><br>
                        
                        <strong>Operations:</strong><br>
                        â€¢ send(message)<br>
                        â€¢ receive(message)<br><br>
                        
                        <strong>Advantages:</strong><br>
                        âœ“ Easier to implement<br>
                        âœ“ Works for distributed systems<br>
                        âœ“ No conflicts (OS manages)<br><br>
                        
                        <strong>Disadvantages:</strong><br>
                        âœ— Slower (kernel calls needed)<br>
                        âœ— Overhead for small messages
                    </div>
                    
                    <div class="code-box"><strong>Comparison:</strong>

Aspect          | Shared Memory    | Message Passing
--------------- | ---------------- | ----------------
Speed           | Fast             | Slower
Implementation  | Complex          | Easier
Synchronization | Manual needed    | OS handles
Use case        | Large data       | Small messages
Location        | Same machine     | Can be distributed</div>
                </div>
            </div>
            
            <!-- Section 12: Remote Procedure Calls -->
            <div class="section">
                <div class="section-title">12. Remote Procedure Calls (RPC)</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>Remote Procedure Call (RPC):</strong><br>
                        Allows a program to execute a procedure (function) on another machine as if it were a local call. Makes distributed computing transparent.
                    </div>
                    
                    <div class="example-box">
                        <strong>Real-life Analogy:</strong><br>
                        Ordering food by phone:<br>
                        â€¢ You call restaurant (remote machine)<br>
                        â€¢ Ask for pizza (call procedure)<br>
                        â€¢ Wait for delivery (wait for result)<br>
                        â€¢ Get pizza (receive result)<br><br>
                        You don't go to restaurant yourself - phone call handles everything!
                    </div>
                    
                    <div class="code-box"><strong>How RPC Works:</strong>

Client Machine              Server Machine
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Client calls â”‚           â”‚              â”‚
â”‚ add(5, 3)    â”‚           â”‚              â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚              â”‚
       â”‚                   â”‚              â”‚
       â†“                   â”‚              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚              â”‚
â”‚ Client Stub  â”‚           â”‚              â”‚
â”‚ (packs args) â”‚           â”‚              â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚              â”‚
       â”‚                   â”‚              â”‚
       â”‚  Network          â”‚              â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚              â”‚
                           â†“              â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
                    â”‚ Server Stub  â”‚     â”‚
                    â”‚ (unpacks)    â”‚     â”‚
                    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
                           â†“              â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
                    â”‚ Execute      â”‚     â”‚
                    â”‚ add(5,3)=8   â”‚     â”‚
                    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
                           â”‚              â”‚
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
       â”‚  Result = 8                      â”‚
       â†“                                  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                         â”‚
â”‚ Client gets 8â”‚                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                         â””</div>
                    
                    <div class="note-box">
                        <strong>Key Point:</strong> Client doesn't know the function is executing remotely. RPC makes remote calls look like local calls!
                    </div>
                </div>
            </div>
            
            <!-- Section 13: Process Synchronization -->
            <div class="section">
                <div class="section-title">13. Process Synchronization</div>
                <div class="content">
                    <div class="definition-box">
                        <strong>Process Synchronization:</strong><br>
                        Coordination of execution of multiple processes to ensure data consistency when processes access shared resources.
                    </div>
                    
                    <div class="example-box">
                        <strong>Why Synchronization Needed?</strong><br><br>
                        
                        <strong>Example - Bank Account (Race Condition):</strong><br>
                        Initial Balance = â‚¹1000<br><br>
                        
                        <strong>Process A:</strong> Withdraw â‚¹500<br>
                        1. Read balance (â‚¹1000)<br>
                        2. Calculate: 1000 - 500 = â‚¹500<br>
                        3. Write back â‚¹500<br><br>
                        
                        <strong>Process B:</strong> Deposit â‚¹300 (runs simultaneously)<br>
                        1. Read balance (â‚¹1000) â† Wrong! Should be â‚¹500<br>
                        2. Calculate: 1000 + 300 = â‚¹1300<br>
                        3. Write back â‚¹1300<br><br>
                        
                        <strong>Final Balance:</strong> â‚¹1300 (Wrong! Should be â‚¹800)<br>
                        â‚¹500 deposit lost! This is a <strong>race condition</strong>.
                    </div>
                    
                    <div class="subsection-title">Critical Section Problem:</div>
                    <div class="definition-box">
                        <strong>Critical Section:</strong> Part of code where shared resources are accessed. Only one process should execute in critical section at a time.
                    </div>
                    
                    <div class="code-box"><strong>Critical Section Structure:</strong>

do {
    // Entry Section (request permission)
    
    // CRITICAL SECTION
    // (access shared resource)
    
    // Exit Section (release permission)
    
    // Remainder Section
    // (other code)
    
} while (true);</div>
                    
                    <div class="subsection-title">Requirements for Solution:</div>
                    <div class="step-box">
                        <strong>1. Mutual Exclusion:</strong><br>
                        Only one process in critical section at a time<br><br>
                        
                        <strong>2. Progress:</strong><br>
                        If no process in critical section, selection of next process cannot be postponed indefinitely<br><br>
                        
                        <strong>3. Bounded Waiting:</strong><br>
                        Limit on number of times other processes can enter CS before a waiting process gets turn (no starvation)
                    </div>
                    
                    <div class="note-box">
                        <strong>Synchronization Mechanisms:</strong><br>
                        â€¢ Semaphores<br>
                        â€¢ Monitors<br>
                        â€¢ Mutex locks<br>
                        (Covered in detail in Unit 2)
                    </div>
                </div>
            </div>
            
        </div>
        
        <!-- LAST MIN NOTES TAB -->
        <div class="tab-content" id="lastMinTab">
            <div class="chapter-title">
                <span>âš¡</span>
                <span>Last Minute Notes - Quick Revision (5-10 mins)</span>
            </div>
            
            <div class="section">
                <div class="note-box">
                    <strong>ğŸ“Œ How to Use:</strong> Read this 5-10 minutes before exam for quick revision of all key concepts!
                </div>
            </div>
            
            <!-- Introduction -->
            <div class="section">
                <div class="section-title">ğŸ’» Introduction to OS</div>
                <div class="content">
                    <div class="code-box">Operating System = Interface between hardware and applications

<strong>Goals:</strong> Convenience, Efficiency, Resource Management, Security

<strong>OS Structures:</strong>
â€¢ Monolithic: All in kernel (fast but risky)
â€¢ Layered: Layer by layer (modular)
â€¢ Microkernel: Minimal kernel (reliable)
â€¢ Modular: Loadable modules (flexible)

<strong>Main Functions:</strong>
1. Process Management
2. Memory Management
3. File Management
4. I/O Management
5. Security</div>
                </div>
            </div>
            
            <!-- Types of OS -->
            <div class="section">
                <div class="section-title">ğŸ”„ Types of OS</div>
                <div class="content">
                    <div class="code-box">Batch: Jobs in batches, no interaction
Time-Sharing: Multiple users, time slicing
Real-Time: Hard (strict deadline), Soft (flexible)
Distributed: Multiple computers as one system
Mobile: Android, iOS (touch, battery optimized)</div>
                </div>
            </div>
            
            <!-- System Calls -->
            <div class="section">
                <div class="section-title">ğŸ“ System Calls</div>
                <div class="content">
                    <div class="code-box"><strong>System Call:</strong> Interface between user program and OS kernel

<strong>User Mode:</strong> Limited privileges
<strong>Kernel Mode:</strong> Full access to hardware

<strong>5 Types:</strong>
1. Process Control: fork(), exit(), wait()
2. File Management: open(), read(), write()
3. Device Management: ioctl()
4. Information: getpid(), time()
5. Communication: send(), receive()</div>
                </div>
            </div>
            
            <!-- Process -->
            <div class="section">
                <div class="section-title">âš™ï¸ Process Management</div>
                <div class="content">
                    <div class="code-box"><strong>Process:</strong> Program in execution

<strong>Process vs Program:</strong>
Program = Passive (code on disk)
Process = Active (running in memory)

<strong>PCB (Process Control Block):</strong>
Contains: PID, State, PC, Registers, Priority, Memory info

<strong>5 Process States:</strong>
New â†’ Ready â†’ Running â†’ Waiting â†’ Terminated

<strong>Context Switch:</strong> Save current process, Load next process
(Pure overhead, takes 1-10 Î¼s)

<strong>3 Schedulers:</strong>
â€¢ Long-term: New â†’ Ready (minutes)
â€¢ Short-term: Ready â†’ Running (milliseconds)
â€¢ Medium-term: Swapping (memory management)</div>
                </div>
            </div>
            
            <!-- Threads -->
            <div class="section">
                <div class="section-title">ğŸ§µ Threads</div>
                <div class="content">
                    <div class="code-box"><strong>Thread:</strong> Lightweight process

<strong>Benefits:</strong>
â€¢ Responsiveness
â€¢ Resource sharing
â€¢ Economy (cheaper than process)
â€¢ Scalability (use multiple cores)

<strong>Types:</strong>
User-Level: Fast but blocks entire process
Kernel-Level: Slower but true parallelism

<strong>Models:</strong>
â€¢ Many-to-One: All threads â†’ 1 kernel thread
â€¢ One-to-One: Each thread â†’ 1 kernel thread
â€¢ Many-to-Many: Multiple â†’ Multiple (flexible)</div>
                </div>
            </div>
            
            <!-- CPU Scheduling -->
            <div class="section">
                <div class="section-title">ğŸ“Š CPU Scheduling</div>
                <div class="content">
                    <div class="code-box"><strong>Preemptive:</strong> Can interrupt (RR, SRTF, Priority)
<strong>Non-Preemptive:</strong> Cannot interrupt (FCFS, SJF)

<strong>5 Criteria:</strong>
1. CPU Utilization (Maximize)
2. Throughput (Maximize)
3. Turnaround Time (Minimize)
4. Waiting Time (Minimize)
5. Response Time (Minimize)

<strong>Formulas:</strong>
Turnaround Time = Completion Time - Arrival Time
Waiting Time = Turnaround Time - Burst Time
Response Time = First Response - Arrival Time</div>
                </div>
            </div>
            
            <!-- Scheduling Algorithms -->
            <div class="section">
                <div class="section-title">â±ï¸ Scheduling Algorithms</div>
                <div class="content">
                    <div class="code-box"><strong>FCFS:</strong> First Come First Serve
â€¢ Simple, no starvation
â€¢ Convoy effect problem

<strong>SJF:</strong> Shortest Job First
â€¢ Optimal (minimum avg WT)
â€¢ Starvation possible

<strong>SRTF:</strong> Shortest Remaining Time First
â€¢ Preemptive SJF
â€¢ Better than SJF

<strong>Priority:</strong> Based on priority number
â€¢ Starvation (solve with Aging)

<strong>Round Robin:</strong> Time quantum (q)
â€¢ Fair, no starvation
â€¢ Context switch overhead
â€¢ q too large â†’ FCFS
â€¢ q too small â†’ too much overhead

<strong>Multilevel Queue:</strong> Multiple queues
â€¢ Different algorithms per queue
â€¢ Can cause starvation</div>
                </div>
            </div>
            
            <!-- IPC -->
            <div class="section">
                <div class="section-title">ğŸ’¬ IPC & Synchronization</div>
                <div class="content">
                    <div class="code-box"><strong>IPC (Inter-process Communication):</strong>

<strong>Shared Memory:</strong> Fast, needs synchronization
<strong>Message Passing:</strong> Slower, easier to implement

<strong>RPC (Remote Procedure Call):</strong>
Execute function on remote machine as if local

<strong>Process Synchronization:</strong>
Coordinate processes accessing shared resources

<strong>Race Condition:</strong> Multiple processes access shared data
simultaneously â†’ incorrect result

<strong>Critical Section:</strong> Code accessing shared resource
Only one process at a time

<strong>Requirements:</strong>
1. Mutual Exclusion
2. Progress
3. Bounded Waiting</div>
                </div>
            </div>
            
            <!-- Important Points -->
            <div class="section">
                <div class="section-title">âš ï¸ Important Exam Points</div>
                <div class="content">
                    <div class="threat-box">
                        <strong>Must Remember:</strong><br>
                        âŒ Process vs Thread differences<br>
                        âŒ 5 Process states and transitions<br>
                        âŒ PCB components<br>
                        âŒ Preemptive vs Non-preemptive<br>
                        âŒ All 5 scheduling criteria formulas<br>
                        âŒ Scheduling algorithm examples (Gantt charts)<br>
                        âŒ Convoy effect (FCFS)<br>
                        âŒ Starvation vs Deadlock<br>
                        âŒ User mode vs Kernel mode<br>
                        âŒ Context switch overhead
                    </div>
                </div>
            </div>
            
            <!-- Quick Tips -->
            <div class="section">
                <div class="section-title">ğŸ’¡ Exam Strategy</div>
                <div class="content">
                    <div class="example-box">
                        <strong>For Scheduling Problems:</strong><br>
                        1. Draw Gantt chart first<br>
                        2. Calculate completion time for each process<br>
                        3. Use formulas: TAT = CT - AT, WT = TAT - BT<br>
                        4. Take average of all processes<br>
                        5. Show all steps!<br><br>
                        
                        <strong>For Theory Questions:</strong><br>
                        â€¢ Define clearly<br>
                        â€¢ Give real-life example<br>
                        â€¢ List advantages/disadvantages<br>
                        â€¢ Compare if asked<br><br>
                        
                        <strong>Common Mistakes to Avoid:</strong><br>
                        âœ— Confusing Turnaround Time and Waiting Time<br>
                        âœ— Forgetting arrival time in calculations<br>
                        âœ— Wrong Gantt chart in SRTF (must check at each arrival)<br>
                        âœ— Not specifying time quantum in Round Robin
                    </div>
                </div>
            </div>
            
            <!-- Final Tips -->
            <div class="section">
                <div class="section-title">ğŸŒŸ Final Tips</div>
                <div class="content">
                    <div class="note-box" style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.1) 0%, rgba(59, 130, 246, 0.1) 100%); border-left: 4px solid var(--success);">
                        <strong>Remember:</strong><br>
                        â€¢ OS manages hardware and provides services<br>
                        â€¢ Process = Active, Program = Passive<br>
                        â€¢ PCB stores all process information<br>
                        â€¢ Context switch is overhead<br>
                        â€¢ No perfect scheduling algorithm - each has trade-offs<br>
                        â€¢ Synchronization prevents race conditions<br><br>
                        
                        <strong>ğŸ¯ All the Best!</strong><br>
                        Practice Gantt charts for scheduling problems. Understand concepts with real-life examples. You've got this! ğŸ’ªğŸš€
                    </div>
                </div>
            </div>
            
        </div>
        
    </div>
    
    <!-- Footer -->
    <div class="footer">
        <div class="footer-credit">
            Made with ğŸ’™ by <strong>Ankush Raj</strong>
        </div>
        <p class="footer-note">
            Â© 2026 <a href="https://ankushraj.dev" target="_blank" style="color: var(--primary); text-decoration: none; font-weight: 600;">ankushraj.dev</a> - All Rights Reserved
        </p>
    </div>
    
    <script>
        // Dark Mode Toggle
        const darkModeBtn = document.getElementById('darkModeBtn');
        const isDarkMode = localStorage.getItem('darkMode') === 'true';
        
        if (isDarkMode) {
            document.body.classList.add('dark-mode');
            updateDarkModeBtn(true);
        }
        
        function toggleDarkMode() {
            document.body.classList.toggle('dark-mode');
            const isDark = document.body.classList.contains('dark-mode');
            localStorage.setItem('darkMode', isDark);
            updateDarkModeBtn(isDark);
        }
        
        function updateDarkModeBtn(isDark) {
            const btn = document.getElementById('darkModeBtn');
            btn.innerHTML = isDark 
                ? '<span>â˜€ï¸</span><span>Light</span>' 
                : '<span>ğŸŒ™</span><span>Dark</span>';
        }
        
        // TOC Toggle
        function openTOC() {
            document.getElementById('tocPanel').classList.add('active');
            document.getElementById('overlay').classList.add('active');
        }
        
        function closeTOC() {
            document.getElementById('tocPanel').classList.remove('active');
            document.getElementById('overlay').classList.remove('active');
        }
        
        // Tab Switching
        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            if (tabName === 'full') {
                document.querySelectorAll('.tab')[0].classList.add('active');
                document.getElementById('fullNotesTab').classList.add('active');
            } else {
                document.querySelectorAll('.tab')[1].classList.add('active');
                document.getElementById('lastMinTab').classList.add('active');
            }
            
            window.scrollTo({top: 0, behavior: 'smooth'});
        }
        
        // Build TOC
        const chapters = [
            { title: 'Introduction to OS', id: 'ch1' },
            { title: 'Process Management', id: 'ch2' }
        ];
        
        const tocList = document.getElementById('tocList');
        chapters.forEach((ch, index) => {
            const li = document.createElement('li');
            li.innerHTML = `<span style="color: var(--primary); font-weight: 700;">${index + 1}.</span> ${ch.title}`;
            li.onclick = () => {
                const element = document.getElementById(ch.id);
                if (element) {
                    element.scrollIntoView({ behavior: 'smooth' });
                }
                closeTOC();
            };
            tocList.appendChild(li);
        });
    </script>
</body>
</html>